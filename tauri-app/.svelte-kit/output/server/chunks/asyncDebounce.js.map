{"version":3,"file":"asyncDebounce.js","sources":["../../../../src/lib/services/config.ts","../../../../src/lib/components/FileTextarea.svelte","../../../../src/lib/services/configCodemirrorProblems.ts","../../../../src/lib/utils/asyncDebounce.ts"],"sourcesContent":["import { settingsText } from '$lib/stores/settings';\nimport { globalDotrainFile } from '$lib/storesGeneric/textFileStore';\nimport type { DeploymentCfg, ScenarioCfg } from '@rainlanguage/orderbook';\nimport { invoke } from '@tauri-apps/api';\nimport { get } from 'svelte/store';\n\nexport const checkSettingsErrors = (text: string[]): Promise<void> =>\n  invoke('check_settings_errors', { text });\n\nexport const checkDotrainWithSettingsErrors = (\n  dotrain: string,\n  settings: string[],\n): Promise<void> =>\n  invoke('check_dotrain_with_settings_errors', {\n    dotrain,\n    settings,\n  });\n\nexport const getDeployments = (): Promise<Record<string, DeploymentCfg>> => {\n  if (!get(globalDotrainFile).text) {\n    return Promise.resolve({});\n  }\n  return invoke('get_deployments', {\n    dotrain: get(globalDotrainFile).text,\n    settings: get(settingsText),\n  });\n};\n\nexport const getScenarios = (): Promise<Record<string, ScenarioCfg>> => {\n  if (!get(globalDotrainFile).text) {\n    return Promise.resolve({});\n  }\n  return invoke('get_scenarios', {\n    dotrain: get(globalDotrainFile).text,\n    settings: get(settingsText),\n  });\n};\n","<script lang=\"ts\">\n  import type { TextFileStore } from '$lib/storesGeneric/textFileStore';\n  import { ButtonLoading } from '@rainlanguage/ui-components';\n\n  export let textFile: TextFileStore;\n</script>\n\n<div class=\"flex w-full flex-col\">\n  <div class=\"flex items-end gap-x-4\">\n    <div class=\"flex-grow\">\n      <slot name=\"alert\" />\n    </div>\n    <div class=\"flex flex-col items-end justify-end gap-2\">\n      <div class=\"flex gap-x-2\">\n        {#if $textFile.path}\n          <ButtonLoading loading={$textFile.isSaving} color=\"green\" on:click={textFile.saveFile}\n            >Save</ButtonLoading\n          >\n        {/if}\n        <ButtonLoading loading={$textFile.isSavingAs} color=\"green\" on:click={textFile.saveFileAs}\n          >Save As</ButtonLoading\n        >\n        <ButtonLoading loading={$textFile.isLoading} color=\"blue\" on:click={textFile.loadFile}\n          >Load</ButtonLoading\n        >\n      </div>\n\n      {#if $textFile.path}\n        <div\n          class=\"flex w-full justify-end overflow-hidden overflow-ellipsis text-xs text-gray-500 dark:text-gray-400\"\n        >\n          {$textFile.path}\n        </div>\n      {/if}\n    </div>\n  </div>\n</div>\n\n<div class=\"my-4 overflow-hidden rounded-lg border dark:border-none\">\n  <slot name=\"textarea\" />\n</div>\n\n<div class=\"my-4\">\n  <slot name=\"additionalFields\" />\n</div>\n\n<div class=\"flex justify-end\">\n  <slot name=\"submit\" />\n</div>\n","import { ErrorCode, type Problem } from 'codemirror-rainlang';\nimport { reportErrorToSentry, SentrySeverityLevel } from '$lib/services/sentry';\nimport { checkDotrainWithSettingsErrors, checkSettingsErrors } from './config';\n\nexport async function checkConfigErrors(settings: string[]): Promise<Problem[]> {\n  const problems: Problem[] = [];\n\n  try {\n    await checkSettingsErrors(settings);\n  } catch (e) {\n    reportErrorToSentry(e, SentrySeverityLevel.Info);\n    problems.push(convertErrorToProblem(e));\n  }\n\n  return problems;\n}\n\nexport async function checkDotrainErrors(dotrain: string, settings: string[]) {\n  const problems: Problem[] = [];\n\n  try {\n    await checkDotrainWithSettingsErrors(dotrain, settings);\n  } catch (e) {\n    reportErrorToSentry(e, SentrySeverityLevel.Info);\n    problems.push(convertErrorToProblem(e));\n  }\n\n  return problems;\n}\n\nfunction convertErrorToProblem(e: unknown) {\n  return {\n    msg: typeof e === 'string' ? e : e instanceof Error ? e.message : 'something went wrong!',\n    position: [0, 0],\n    code: ErrorCode.InvalidRainDocument,\n  } as Problem;\n}\n","import { debounce } from 'lodash';\nimport { get, writable } from 'svelte/store';\n\n/**\n * Creates a debounced asynchronous function that calls the original function\n * only once after the last call within a specified wait time.\n *\n * @template T - The type of the arguments passed to the original function.\n * @template R - The type of the result returned by the original function.\n * @param {(...args: T) => Promise<R>} fn - The original function to be debounced.\n * @param {number} wait - The wait time in milliseconds before invoking the debounced function.\n * @param {(result: R) => void} onSuccess - The success callback function to be invoked with the result.\n * @param {(error: unknown) => void} onError - The error callback function to be invoked with the error.\n * @returns {(...args: T) => void} - The debounced function.\n */\nexport function createDebouncedAsyncFn<T extends unknown[], R>(\n  fn: (...args: T) => Promise<R>,\n  wait: number,\n  onSuccess: (result: R) => void,\n  onError: (error: unknown) => void,\n): (...args: T) => void {\n  let currentArgs: T | undefined;\n\n  const executeFn = async (args: T) => {\n    const argsNotEqual = (args: T, currentArgs?: T) =>\n      JSON.stringify(currentArgs) !== JSON.stringify(args);\n    try {\n      const result = await fn(...args);\n      if (argsNotEqual(args, currentArgs)) return;\n      onSuccess(result);\n    } catch (error) {\n      if (argsNotEqual(args, currentArgs)) return;\n      onError(error);\n    }\n  };\n\n  const debouncedFn = debounce((...args: T) => {\n    return executeFn(args);\n  }, wait);\n\n  return (...args: T): void => {\n    currentArgs = args;\n    debouncedFn(...args);\n  };\n}\n\n/**\n * Creates a debounced asynchronous function that calls the original function\n * only once after the last call within a specified wait time.\n *\n * The function returns a debounced function along with writable stores for the result and error.\n *\n * @template T - The type of the arguments passed to the original function.\n * @template R - The type of the result returned by the original function.\n * @param {(...args: T) => Promise<R>} fn - The original function to be debounced.\n * @param {number} wait - The wait time in milliseconds before invoking the debounced function.\n * @returns {{ debouncedFn: (...args: T) => void, result: import('svelte/store').Writable<R | undefined>, error: import('svelte/store').Writable<unknown | undefined> }} - The debounced function and the result and error stores.\n */\nexport function useDebouncedFn<T extends unknown[], R>(\n  fn: (...args: T) => Promise<R>,\n  wait: number,\n) {\n  const result = writable<R | undefined>(undefined);\n  const error = writable<unknown | undefined>(undefined);\n\n  const debouncedFn = createDebouncedAsyncFn<T, R>(\n    fn,\n    wait,\n    (res: R) => {\n      result.set(res);\n      error.set(undefined); // Reset error store on successful execution\n    },\n    (err: unknown) => {\n      error.set(err);\n      result.set(undefined); // Reset result store on error\n    },\n  );\n\n  return { debouncedFn, result, error };\n}\n\nif (import.meta.vitest) {\n  const { it, expect, vi } = import.meta.vitest;\n\n  it('creates a debounced async function that only calls the original function once after the last call', async () => {\n    let callCount = 0;\n    const debouncedFn = createDebouncedAsyncFn(\n      async () => {\n        callCount++;\n      },\n      100,\n      () => {},\n      () => {},\n    );\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 50));\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(callCount).toEqual(1);\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 50));\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(callCount).toEqual(2);\n  });\n\n  it('calls the onSuccess callback with the result of the original function', async () => {\n    const onSuccess = vi.fn();\n    const onError = vi.fn();\n\n    const debouncedFn = createDebouncedAsyncFn(\n      async (value: number) => {\n        return value * 2;\n      },\n      100,\n      onSuccess,\n      onError,\n    );\n\n    debouncedFn(5);\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(onSuccess).toHaveBeenCalledWith(10);\n  });\n\n  it('calls the onError callback if the original function throws an error', async () => {\n    const onSuccess = vi.fn();\n    const onError = vi.fn();\n\n    const debouncedFn = createDebouncedAsyncFn(\n      async () => {\n        throw new Error('Test error');\n      },\n      100,\n      onSuccess,\n      onError,\n    );\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(onError).toHaveBeenCalledWith(expect.any(Error));\n    expect(onError.mock.calls[0][0]).toHaveProperty('message', 'Test error');\n  });\n\n  it('passes the arguments to the original function', async () => {\n    const onSuccess = vi.fn();\n    const onError = vi.fn();\n\n    const debouncedFn = createDebouncedAsyncFn(\n      async (value: number) => {\n        return value * 2;\n      },\n      100,\n      onSuccess,\n      onError,\n    );\n\n    debouncedFn(5);\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(onSuccess).toHaveBeenCalledWith(10);\n  });\n\n  // tests for useDebouncedFn\n  it('creates a debounced async function that only calls the original function once after the last call', async () => {\n    let callCount = 0;\n    const { debouncedFn } = useDebouncedFn(async () => {\n      callCount++;\n    }, 100);\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 50));\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(callCount).toEqual(1);\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 50));\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(callCount).toEqual(2);\n  });\n\n  it('calls the onSuccess callback with the result of the original function', async () => {\n    const { debouncedFn, result } = useDebouncedFn(async (value: number) => {\n      return value * 2;\n    }, 100);\n\n    debouncedFn(5);\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(get(result)).toEqual(10);\n  });\n\n  it('calls the onError callback if the original function throws an error', async () => {\n    const { debouncedFn, error } = useDebouncedFn(async () => {\n      throw new Error('Test error');\n    }, 100);\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(get(error)).toHaveProperty('message', 'Test error');\n  });\n}\n"],"names":["get","args","currentArgs"],"mappings":"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"}