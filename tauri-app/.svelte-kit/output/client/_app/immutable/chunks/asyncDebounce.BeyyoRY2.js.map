{"version":3,"file":"asyncDebounce.BeyyoRY2.js","sources":["../../../../../../src/lib/components/FileTextarea.svelte","../../../../../../src/lib/services/configCodemirrorProblems.ts","../../../../../../src/lib/utils/asyncDebounce.ts"],"sourcesContent":["<script lang=\"ts\">\n  import type { TextFileStore } from '$lib/storesGeneric/textFileStore';\n  import { ButtonLoading } from '@rainlanguage/ui-components';\n\n  export let textFile: TextFileStore;\n</script>\n\n<div class=\"flex w-full flex-col\">\n  <div class=\"flex items-end gap-x-4\">\n    <div class=\"flex-grow\">\n      <slot name=\"alert\" />\n    </div>\n    <div class=\"flex flex-col items-end justify-end gap-2\">\n      <div class=\"flex gap-x-2\">\n        {#if $textFile.path}\n          <ButtonLoading loading={$textFile.isSaving} color=\"green\" on:click={textFile.saveFile}\n            >Save</ButtonLoading\n          >\n        {/if}\n        <ButtonLoading loading={$textFile.isSavingAs} color=\"green\" on:click={textFile.saveFileAs}\n          >Save As</ButtonLoading\n        >\n        <ButtonLoading loading={$textFile.isLoading} color=\"blue\" on:click={textFile.loadFile}\n          >Load</ButtonLoading\n        >\n      </div>\n\n      {#if $textFile.path}\n        <div\n          class=\"flex w-full justify-end overflow-hidden overflow-ellipsis text-xs text-gray-500 dark:text-gray-400\"\n        >\n          {$textFile.path}\n        </div>\n      {/if}\n    </div>\n  </div>\n</div>\n\n<div class=\"my-4 overflow-hidden rounded-lg border dark:border-none\">\n  <slot name=\"textarea\" />\n</div>\n\n<div class=\"my-4\">\n  <slot name=\"additionalFields\" />\n</div>\n\n<div class=\"flex justify-end\">\n  <slot name=\"submit\" />\n</div>\n","import { ErrorCode, type Problem } from 'codemirror-rainlang';\nimport { reportErrorToSentry, SentrySeverityLevel } from '$lib/services/sentry';\nimport { checkDotrainWithSettingsErrors, checkSettingsErrors } from './config';\n\nexport async function checkConfigErrors(settings: string[]): Promise<Problem[]> {\n  const problems: Problem[] = [];\n\n  try {\n    await checkSettingsErrors(settings);\n  } catch (e) {\n    reportErrorToSentry(e, SentrySeverityLevel.Info);\n    problems.push(convertErrorToProblem(e));\n  }\n\n  return problems;\n}\n\nexport async function checkDotrainErrors(dotrain: string, settings: string[]) {\n  const problems: Problem[] = [];\n\n  try {\n    await checkDotrainWithSettingsErrors(dotrain, settings);\n  } catch (e) {\n    reportErrorToSentry(e, SentrySeverityLevel.Info);\n    problems.push(convertErrorToProblem(e));\n  }\n\n  return problems;\n}\n\nfunction convertErrorToProblem(e: unknown) {\n  return {\n    msg: typeof e === 'string' ? e : e instanceof Error ? e.message : 'something went wrong!',\n    position: [0, 0],\n    code: ErrorCode.InvalidRainDocument,\n  } as Problem;\n}\n","import { debounce } from 'lodash';\nimport { get, writable } from 'svelte/store';\n\n/**\n * Creates a debounced asynchronous function that calls the original function\n * only once after the last call within a specified wait time.\n *\n * @template T - The type of the arguments passed to the original function.\n * @template R - The type of the result returned by the original function.\n * @param {(...args: T) => Promise<R>} fn - The original function to be debounced.\n * @param {number} wait - The wait time in milliseconds before invoking the debounced function.\n * @param {(result: R) => void} onSuccess - The success callback function to be invoked with the result.\n * @param {(error: unknown) => void} onError - The error callback function to be invoked with the error.\n * @returns {(...args: T) => void} - The debounced function.\n */\nexport function createDebouncedAsyncFn<T extends unknown[], R>(\n  fn: (...args: T) => Promise<R>,\n  wait: number,\n  onSuccess: (result: R) => void,\n  onError: (error: unknown) => void,\n): (...args: T) => void {\n  let currentArgs: T | undefined;\n\n  const executeFn = async (args: T) => {\n    const argsNotEqual = (args: T, currentArgs?: T) =>\n      JSON.stringify(currentArgs) !== JSON.stringify(args);\n    try {\n      const result = await fn(...args);\n      if (argsNotEqual(args, currentArgs)) return;\n      onSuccess(result);\n    } catch (error) {\n      if (argsNotEqual(args, currentArgs)) return;\n      onError(error);\n    }\n  };\n\n  const debouncedFn = debounce((...args: T) => {\n    return executeFn(args);\n  }, wait);\n\n  return (...args: T): void => {\n    currentArgs = args;\n    debouncedFn(...args);\n  };\n}\n\n/**\n * Creates a debounced asynchronous function that calls the original function\n * only once after the last call within a specified wait time.\n *\n * The function returns a debounced function along with writable stores for the result and error.\n *\n * @template T - The type of the arguments passed to the original function.\n * @template R - The type of the result returned by the original function.\n * @param {(...args: T) => Promise<R>} fn - The original function to be debounced.\n * @param {number} wait - The wait time in milliseconds before invoking the debounced function.\n * @returns {{ debouncedFn: (...args: T) => void, result: import('svelte/store').Writable<R | undefined>, error: import('svelte/store').Writable<unknown | undefined> }} - The debounced function and the result and error stores.\n */\nexport function useDebouncedFn<T extends unknown[], R>(\n  fn: (...args: T) => Promise<R>,\n  wait: number,\n) {\n  const result = writable<R | undefined>(undefined);\n  const error = writable<unknown | undefined>(undefined);\n\n  const debouncedFn = createDebouncedAsyncFn<T, R>(\n    fn,\n    wait,\n    (res: R) => {\n      result.set(res);\n      error.set(undefined); // Reset error store on successful execution\n    },\n    (err: unknown) => {\n      error.set(err);\n      result.set(undefined); // Reset result store on error\n    },\n  );\n\n  return { debouncedFn, result, error };\n}\n\nif (import.meta.vitest) {\n  const { it, expect, vi } = import.meta.vitest;\n\n  it('creates a debounced async function that only calls the original function once after the last call', async () => {\n    let callCount = 0;\n    const debouncedFn = createDebouncedAsyncFn(\n      async () => {\n        callCount++;\n      },\n      100,\n      () => {},\n      () => {},\n    );\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 50));\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(callCount).toEqual(1);\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 50));\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(callCount).toEqual(2);\n  });\n\n  it('calls the onSuccess callback with the result of the original function', async () => {\n    const onSuccess = vi.fn();\n    const onError = vi.fn();\n\n    const debouncedFn = createDebouncedAsyncFn(\n      async (value: number) => {\n        return value * 2;\n      },\n      100,\n      onSuccess,\n      onError,\n    );\n\n    debouncedFn(5);\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(onSuccess).toHaveBeenCalledWith(10);\n  });\n\n  it('calls the onError callback if the original function throws an error', async () => {\n    const onSuccess = vi.fn();\n    const onError = vi.fn();\n\n    const debouncedFn = createDebouncedAsyncFn(\n      async () => {\n        throw new Error('Test error');\n      },\n      100,\n      onSuccess,\n      onError,\n    );\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(onError).toHaveBeenCalledWith(expect.any(Error));\n    expect(onError.mock.calls[0][0]).toHaveProperty('message', 'Test error');\n  });\n\n  it('passes the arguments to the original function', async () => {\n    const onSuccess = vi.fn();\n    const onError = vi.fn();\n\n    const debouncedFn = createDebouncedAsyncFn(\n      async (value: number) => {\n        return value * 2;\n      },\n      100,\n      onSuccess,\n      onError,\n    );\n\n    debouncedFn(5);\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(onSuccess).toHaveBeenCalledWith(10);\n  });\n\n  // tests for useDebouncedFn\n  it('creates a debounced async function that only calls the original function once after the last call', async () => {\n    let callCount = 0;\n    const { debouncedFn } = useDebouncedFn(async () => {\n      callCount++;\n    }, 100);\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 50));\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(callCount).toEqual(1);\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 50));\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(callCount).toEqual(2);\n  });\n\n  it('calls the onSuccess callback with the result of the original function', async () => {\n    const { debouncedFn, result } = useDebouncedFn(async (value: number) => {\n      return value * 2;\n    }, 100);\n\n    debouncedFn(5);\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(get(result)).toEqual(10);\n  });\n\n  it('calls the onError callback if the original function throws an error', async () => {\n    const { debouncedFn, error } = useDebouncedFn(async () => {\n      throw new Error('Test error');\n    }, 100);\n\n    debouncedFn();\n\n    await new Promise((resolve) => setTimeout(resolve, 150)); // Wait for debounce and async function\n\n    expect(get(error)).toHaveProperty('message', 'Test error');\n  });\n}\n"],"names":["ctx","is_function","dirty","buttonloading_changes","t_value","insert_hydration","target","div","anchor","set_data","t","if_block0","create_if_block_1","if_block1","create_if_block","div4","append_hydration","div3","div0","div2","div1","div5","div6","div7","buttonloading0_changes","buttonloading1_changes","textFile","$$props","checkConfigErrors","settings","problems","checkSettingsErrors","e","reportErrorToSentry","SentrySeverityLevel","convertErrorToProblem","checkDotrainErrors","dotrain","checkDotrainWithSettingsErrors","ErrorCode","createDebouncedAsyncFn","fn","wait","onSuccess","onError","currentArgs","executeFn","args","argsNotEqual","result","error","debouncedFn","debounce","useDebouncedFn","writable","res","err"],"mappings":"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"}