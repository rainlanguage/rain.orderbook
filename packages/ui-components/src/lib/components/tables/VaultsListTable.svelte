<script lang="ts">
	import { toHex } from 'viem';
	import { useRaindexClient } from '$lib/hooks/useRaindexClient';
	import {
		Button,
		Checkbox,
		Dropdown,
		DropdownItem,
		TableBodyCell,
		TableHeadCell
	} from 'flowbite-svelte';
	import { goto } from '$app/navigation';
	import { ArrowUpFromBracketOutline, DotsVerticalOutline } from 'flowbite-svelte-icons';
	import { createInfiniteQuery, createQuery } from '@tanstack/svelte-query';
	import TanstackAppTable from '../TanstackAppTable.svelte';
	import ListViewOrderbookFilters from '../ListViewOrderbookFilters.svelte';
	import OrderOrVaultHash from '../OrderOrVaultHash.svelte';
	import Hash, { HashType } from '../Hash.svelte';
	import { DEFAULT_PAGE_SIZE, DEFAULT_REFRESH_INTERVAL } from '../../queries/constants';
	import { Float, RaindexClient, RaindexVault, RaindexVaultsList } from '@rainlanguage/orderbook';
	import { QKEY_TOKENS, QKEY_VAULTS } from '../../queries/keys';
	import type { AppStoresInterface } from '$lib/types/appStores.ts';
	import { useAccount } from '$lib/providers/wallet/useAccount';
	import { getNetworkName } from '$lib/utils/getNetworkName';
	import { getAllContexts } from 'svelte';
	import Tooltip from '../Tooltip.svelte';
	import { useToasts } from '$lib/providers/toasts/useToasts';

	const context = getAllContexts();
	const { errToast } = useToasts();

	export let activeAccountsItems: AppStoresInterface['activeAccountsItems'];
	export let orderHash: AppStoresInterface['orderHash'];
	export let showInactiveOrders: AppStoresInterface['showInactiveOrders'];
	export let hideZeroBalanceVaults: AppStoresInterface['hideZeroBalanceVaults'];
	export let activeTokens: AppStoresInterface['activeTokens'];
	export let selectedChainIds: AppStoresInterface['selectedChainIds'];
	export let showMyItemsOnly: AppStoresInterface['showMyItemsOnly'];
	export let handleDepositModal:
		| ((
				vault: RaindexVault,
				refetch: () => void,
				context: ReturnType<typeof getAllContexts>
		  ) => void)
		| undefined = undefined;
	export let handleWithdrawModal:
		| ((
				vault: RaindexVault,
				refetch: () => void,
				context: ReturnType<typeof getAllContexts>
		  ) => void)
		| undefined = undefined;

	export let onWithdrawAll:
		| ((raindexClient: RaindexClient, vaultsList: RaindexVaultsList) => void | Promise<void>)
		| undefined = undefined;

	const { account } = useAccount();
	const raindexClient = useRaindexClient();

	$: owners =
		$activeAccountsItems && Object.values($activeAccountsItems).length > 0
			? Object.values($activeAccountsItems)
			: $showMyItemsOnly && $account
				? [$account]
				: [];

	$: tokensQuery = createQuery({
		queryKey: [QKEY_TOKENS, $selectedChainIds],
		queryFn: async () => {
			const result = await raindexClient.getAllVaultTokens($selectedChainIds);
			if (result.error) throw new Error(result.error.readableMsg);
			return result.value;
		},
		enabled: true
	});

	$: selectedTokens =
		$activeTokens?.filter(
			(address) => !$tokensQuery.data || $tokensQuery.data.some((t) => t.address === address)
		) ?? [];

	$: query = createInfiniteQuery({
		queryKey: [QKEY_VAULTS, $hideZeroBalanceVaults, $selectedChainIds, owners, selectedTokens],
		queryFn: async ({ pageParam }) => {
			const result = await raindexClient.getVaults(
				$selectedChainIds,
				{
					owners,
					hideZeroBalance: $hideZeroBalanceVaults,
					tokens: selectedTokens
				},
				pageParam + 1
			);
			if (result.error) throw new Error(result.error.readableMsg);
			return result.value;
		},
		initialPageParam: 0,
		getNextPageParam(lastPage, _allPages, lastPageParam) {
			return lastPage.items.length === DEFAULT_PAGE_SIZE ? lastPageParam + 1 : undefined;
		},
		refetchInterval: DEFAULT_REFRESH_INTERVAL,
		enabled: true
	});

	$: if (selectedVaults.size > 0 && !$account) {
		// If User disconnected â€” clear selected vaults
		selectedVaults = new Set<string>();
		selectedVaultsOnChainId = null;
	}

	let selectedVaults = new Set<string>();
	let selectedVaultsOnChainId: number | null = null;
	const getToggleSelectVaultHandler = (vaultId: string, chainId: number) => (e: Event) => {
		e.stopPropagation();

		if (selectedVaults.has(vaultId)) {
			selectedVaults.delete(vaultId);
			if (selectedVaults.size === 0) {
				selectedVaultsOnChainId = null;
			}
		} else {
			selectedVaults.add(vaultId);
			if (selectedVaultsOnChainId === null) {
				selectedVaultsOnChainId = chainId;
			}
		}
		// To trigger Svelte update
		selectedVaults = new Set(selectedVaults);
	};
	const stopPropagation = (e: Event) => e.stopPropagation();
	const handleWithdrawAll = () => {
		const pages = $query.data?.pages ?? [];
		if (!onWithdrawAll || pages.length === 0) {
			return;
		}
		// Combine across all loaded pages so selections beyond the first page are respected
		const selectedIds = Array.from(selectedVaults);
		try {
			// We need to pick by ids from all vaults first to get filtered copies,
			// otherwise it may break wasm reference
			const filteredVaultListResults = pages.reduce(
				(prev, cur) => {
					const result = cur.pickByIds(selectedIds);
					if (result.error) {
						throw new Error(result.error.readableMsg);
					}
					return [...prev, result.value];
				},
				<RaindexVaultsList[]>[]
			);
			// Now we can combine filtered VaultLists into one
			if (filteredVaultListResults.length === 0) {
				errToast('No selected vaults found in the loaded pages. Please refresh and try again.');
				return;
			}
			const [first, ...rest] = filteredVaultListResults;
			const combinedVaultsList = rest.reduce((prev, cur) => {
				const result = prev.concat(cur);
				if (result.error) {
					throw new Error(result.error.readableMsg);
				}
				return result.value;
			}, first);
			return onWithdrawAll(raindexClient, combinedVaultsList);
		} catch (err) {
			if (err instanceof Error) {
				errToast(err.message);
			}
		}
	};

	const ZERO_FLOAT = Float.parse('0').value;
	const isZeroBalance = (item: RaindexVault) => {
		if (!ZERO_FLOAT) return true;
		return item.balance.eq(ZERO_FLOAT).value;
	};
	const isSameChainId = (item: RaindexVault, chainId: number | null) => {
		return chainId === null || chainId === item.chainId;
	};
	const isDisabled = (item: RaindexVault, chainId: number | null) => {
		return !isSameChainId(item, chainId) || isZeroBalance(item);
	};
	const AppTable = TanstackAppTable<RaindexVault, RaindexVaultsList>;
</script>

{#if $query}
	<ListViewOrderbookFilters
		{selectedChainIds}
		{activeAccountsItems}
		{showMyItemsOnly}
		{showInactiveOrders}
		{orderHash}
		{hideZeroBalanceVaults}
		{activeTokens}
		{tokensQuery}
		{selectedTokens}
	/>
	<AppTable
		{query}
		dataSelector={(page) => page.items}
		queryKey={QKEY_VAULTS}
		emptyMessage="No Vaults Found"
		on:clickRow={(e) => {
			goto(`/vaults/${e.detail.item.chainId}-${e.detail.item.orderbook}-${e.detail.item.id}`);
		}}
	>
		<svelte:fragment slot="title">
			<div class="mt-2 flex w-full justify-between">
				<div class="flex items-center gap-x-6">
					<div class="text-3xl font-medium dark:text-white">Vaults</div>
					<Button
						size="xs"
						on:click={handleWithdrawAll}
						disabled={!onWithdrawAll || selectedVaults.size === 0}
						data-testid="withdraw-all-button"
					>
						<ArrowUpFromBracketOutline size="xs" class="mr-2" />
						{selectedVaults.size > 0
							? `Withdraw selected (${selectedVaults.size})`
							: 'Withdraw vaults'}
					</Button>
				</div>
			</div>
		</svelte:fragment>
		<svelte:fragment slot="head">
			<TableHeadCell padding="p-0"><span class="sr-only">Select</span></TableHeadCell>
			<TableHeadCell padding="p-4">Network</TableHeadCell>
			<TableHeadCell padding="px-4 py-4">Vault ID</TableHeadCell>
			<TableHeadCell padding="px-4 py-4">Orderbook</TableHeadCell>
			<TableHeadCell padding="px-4 py-4">Owner</TableHeadCell>
			<TableHeadCell padding="px-2 py-4">Token</TableHeadCell>
			<TableHeadCell padding="px-2 py-4">Balance</TableHeadCell>
			<TableHeadCell padding="px-3 py-4">Input For</TableHeadCell>
			<TableHeadCell padding="px-3 py-4">Output For</TableHeadCell>
		</svelte:fragment>

		<svelte:fragment slot="bodyRow" let:item>
			<TableBodyCell tdClass="px-0" on:click={stopPropagation}>
				<Checkbox
					data-testid="vault-checkbox"
					class={`block px-2 py-4 ${$account?.toLowerCase() !== item.owner.toLowerCase() ? 'invisible' : ''}`}
					checked={selectedVaults.has(item.id)}
					disabled={isDisabled(item, selectedVaultsOnChainId)}
					on:change={getToggleSelectVaultHandler(item.id, item.chainId)}
					on:click={stopPropagation}
					aria-label={`Select vault ${item.id}`}
				/>
				{#if $account?.toLowerCase() === item.owner.toLowerCase() && isDisabled(item, selectedVaultsOnChainId)}
					<Tooltip>
						{isZeroBalance(item)
							? 'This vault has a zero balance'
							: 'This vault is on a different network'}
					</Tooltip>
				{/if}
			</TableBodyCell>

			<TableBodyCell tdClass="px-4 py-2" data-testid="vault-network">
				{getNetworkName(Number(item.chainId))}
			</TableBodyCell>

			<TableBodyCell tdClass="break-all px-4 py-4" data-testid="vault-id">
				<Hash type={HashType.Identifier} value={toHex(item.vaultId)} />
			</TableBodyCell>
			<TableBodyCell tdClass="break-all px-4 py-2 min-w-48" data-testid="vault-orderbook">
				<Hash type={HashType.Identifier} value={item.orderbook} />
			</TableBodyCell>
			<TableBodyCell tdClass="break-all px-4 py-2 min-w-48" data-testid="vault-owner">
				<Hash type={HashType.Wallet} value={item.owner} />
			</TableBodyCell>
			<TableBodyCell tdClass="break-word p-2 min-w-48" data-testid="vault-token"
				>{item.token.name}</TableBodyCell
			>
			<TableBodyCell tdClass="break-all p-2 min-w-48" data-testid="vault-balance">
				{`${item.formattedBalance} ${item.token.symbol}`}
			</TableBodyCell>
			<TableBodyCell tdClass="break-all p-2 min-w-48">
				{#if item.ordersAsInput.length > 0}
					<div data-testid="vault-order-inputs" class="flex flex-wrap items-end justify-start">
						{#each item.ordersAsInput.slice(0, 3) as order}
							<OrderOrVaultHash
								type="orders"
								orderOrVault={order}
								chainId={item.chainId}
								orderbookAddress={item.orderbook}
							/>
						{/each}
						{#if item.ordersAsInput.length > 3}...{/if}
					</div>
				{/if}
			</TableBodyCell>
			<TableBodyCell tdClass="break-all p-2 min-w-48">
				{#if item.ordersAsOutput.length > 0}
					<div data-testid="vault-order-outputs" class="flex flex-wrap items-end justify-start">
						{#each item.ordersAsOutput.slice(0, 3) as order}
							<OrderOrVaultHash
								type="orders"
								orderOrVault={order}
								chainId={item.chainId}
								orderbookAddress={item.orderbook}
							/>
						{/each}
						{#if item.ordersAsOutput.length > 3}...{/if}
					</div>
				{/if}
			</TableBodyCell>
			{#if handleDepositModal && handleWithdrawModal && item.owner.toLowerCase() === $account?.toLowerCase()}
				<TableBodyCell tdClass="px-0 text-right">
					<Button
						color="alternative"
						outline={false}
						data-testid="vault-menu"
						id={`vault-menu-${item.id}`}
						class="mr-2 border-none px-2"
						on:click={(e) => {
							e.stopPropagation();
						}}
					>
						<DotsVerticalOutline class="dark:text-white" />
					</Button>
				</TableBodyCell>

				<Dropdown
					data-testid="dropdown"
					placement="bottom-end"
					triggeredBy={`#vault-menu-${item.id}`}
				>
					<DropdownItem
						data-testid="deposit-button"
						on:click={(e) => {
							e.stopPropagation();
							handleDepositModal(item, $query.refetch, context);
						}}
						>Deposit
					</DropdownItem>
					<DropdownItem
						data-testid="withdraw-button"
						on:click={(e) => {
							e.stopPropagation();
							handleWithdrawModal(item, $query.refetch, context);
						}}
						>Withdraw
					</DropdownItem>
				</Dropdown>
			{/if}
		</svelte:fragment>
	</AppTable>
{/if}
