"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!

  """
  Integer representation of the timestamp stored in blocks for the chain
  """
  timestamp: Int

  """
  The hash of the parent block
  """
  parentHash: Bytes
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

type AddOrder implements Event {
  id: Bytes!

  """
  The order that was added
  """
  order: Order!

  """
  The orderbook this add order event is in
  """
  orderbook: Orderbook!
  transaction: Transaction!

  """
  The msg.sender of this add order call
  """
  sender: Bytes!
}

input AddOrder_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  order: String
  order_not: String
  order_gt: String
  order_lt: String
  order_gte: String
  order_lte: String
  order_in: [String!]
  order_not_in: [String!]
  order_contains: String
  order_contains_nocase: String
  order_not_contains: String
  order_not_contains_nocase: String
  order_starts_with: String
  order_starts_with_nocase: String
  order_not_starts_with: String
  order_not_starts_with_nocase: String
  order_ends_with: String
  order_ends_with_nocase: String
  order_not_ends_with: String
  order_not_ends_with_nocase: String
  order_: Order_filter
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [AddOrder_filter]
  or: [AddOrder_filter]
}

enum AddOrder_orderBy {
  id
  order
  order__id
  order__active
  order__orderHash
  order__owner
  order__nonce
  order__orderBytes
  order__meta
  order__timestampAdded
  orderbook
  orderbook__id
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input BlockChangedFilter {
  number_gte: Int!
}

scalar Bytes

type Clear implements TradeEvent {
  id: Bytes!

  """
  Alice input amount
  """
  aliceInputAmount: Bytes!

  """
  Alice output amount
  """
  aliceOutputAmount: Bytes!

  """
  Bob input amount
  """
  bobInputAmount: Bytes!

  """
  Bob output amount
  """
  bobOutputAmount: Bytes!

  """
  Alice bounty amount
  """
  aliceBountyAmount: Bytes!

  """
  Bob bounty amount
  """
  bobBountyAmount: Bytes!
  aliceBountyVaultBalanceChange: ClearBounty
  bobBountyVaultBalanceChange: ClearBounty

  """
  The orderbook this trade event is for
  """
  orderbook: Orderbook!

  """
  The trades that occured in this event
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]!
  transaction: Transaction!

  """
  The msg.sender of this trade
  """
  sender: Bytes!
}

input Clear_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  aliceInputAmount: Bytes
  aliceInputAmount_not: Bytes
  aliceInputAmount_gt: Bytes
  aliceInputAmount_lt: Bytes
  aliceInputAmount_gte: Bytes
  aliceInputAmount_lte: Bytes
  aliceInputAmount_in: [Bytes!]
  aliceInputAmount_not_in: [Bytes!]
  aliceInputAmount_contains: Bytes
  aliceInputAmount_not_contains: Bytes
  aliceOutputAmount: Bytes
  aliceOutputAmount_not: Bytes
  aliceOutputAmount_gt: Bytes
  aliceOutputAmount_lt: Bytes
  aliceOutputAmount_gte: Bytes
  aliceOutputAmount_lte: Bytes
  aliceOutputAmount_in: [Bytes!]
  aliceOutputAmount_not_in: [Bytes!]
  aliceOutputAmount_contains: Bytes
  aliceOutputAmount_not_contains: Bytes
  bobInputAmount: Bytes
  bobInputAmount_not: Bytes
  bobInputAmount_gt: Bytes
  bobInputAmount_lt: Bytes
  bobInputAmount_gte: Bytes
  bobInputAmount_lte: Bytes
  bobInputAmount_in: [Bytes!]
  bobInputAmount_not_in: [Bytes!]
  bobInputAmount_contains: Bytes
  bobInputAmount_not_contains: Bytes
  bobOutputAmount: Bytes
  bobOutputAmount_not: Bytes
  bobOutputAmount_gt: Bytes
  bobOutputAmount_lt: Bytes
  bobOutputAmount_gte: Bytes
  bobOutputAmount_lte: Bytes
  bobOutputAmount_in: [Bytes!]
  bobOutputAmount_not_in: [Bytes!]
  bobOutputAmount_contains: Bytes
  bobOutputAmount_not_contains: Bytes
  aliceBountyAmount: Bytes
  aliceBountyAmount_not: Bytes
  aliceBountyAmount_gt: Bytes
  aliceBountyAmount_lt: Bytes
  aliceBountyAmount_gte: Bytes
  aliceBountyAmount_lte: Bytes
  aliceBountyAmount_in: [Bytes!]
  aliceBountyAmount_not_in: [Bytes!]
  aliceBountyAmount_contains: Bytes
  aliceBountyAmount_not_contains: Bytes
  bobBountyAmount: Bytes
  bobBountyAmount_not: Bytes
  bobBountyAmount_gt: Bytes
  bobBountyAmount_lt: Bytes
  bobBountyAmount_gte: Bytes
  bobBountyAmount_lte: Bytes
  bobBountyAmount_in: [Bytes!]
  bobBountyAmount_not_in: [Bytes!]
  bobBountyAmount_contains: Bytes
  bobBountyAmount_not_contains: Bytes
  aliceBountyVaultBalanceChange: String
  aliceBountyVaultBalanceChange_not: String
  aliceBountyVaultBalanceChange_gt: String
  aliceBountyVaultBalanceChange_lt: String
  aliceBountyVaultBalanceChange_gte: String
  aliceBountyVaultBalanceChange_lte: String
  aliceBountyVaultBalanceChange_in: [String!]
  aliceBountyVaultBalanceChange_not_in: [String!]
  aliceBountyVaultBalanceChange_contains: String
  aliceBountyVaultBalanceChange_contains_nocase: String
  aliceBountyVaultBalanceChange_not_contains: String
  aliceBountyVaultBalanceChange_not_contains_nocase: String
  aliceBountyVaultBalanceChange_starts_with: String
  aliceBountyVaultBalanceChange_starts_with_nocase: String
  aliceBountyVaultBalanceChange_not_starts_with: String
  aliceBountyVaultBalanceChange_not_starts_with_nocase: String
  aliceBountyVaultBalanceChange_ends_with: String
  aliceBountyVaultBalanceChange_ends_with_nocase: String
  aliceBountyVaultBalanceChange_not_ends_with: String
  aliceBountyVaultBalanceChange_not_ends_with_nocase: String
  aliceBountyVaultBalanceChange_: ClearBounty_filter
  bobBountyVaultBalanceChange: String
  bobBountyVaultBalanceChange_not: String
  bobBountyVaultBalanceChange_gt: String
  bobBountyVaultBalanceChange_lt: String
  bobBountyVaultBalanceChange_gte: String
  bobBountyVaultBalanceChange_lte: String
  bobBountyVaultBalanceChange_in: [String!]
  bobBountyVaultBalanceChange_not_in: [String!]
  bobBountyVaultBalanceChange_contains: String
  bobBountyVaultBalanceChange_contains_nocase: String
  bobBountyVaultBalanceChange_not_contains: String
  bobBountyVaultBalanceChange_not_contains_nocase: String
  bobBountyVaultBalanceChange_starts_with: String
  bobBountyVaultBalanceChange_starts_with_nocase: String
  bobBountyVaultBalanceChange_not_starts_with: String
  bobBountyVaultBalanceChange_not_starts_with_nocase: String
  bobBountyVaultBalanceChange_ends_with: String
  bobBountyVaultBalanceChange_ends_with_nocase: String
  bobBountyVaultBalanceChange_not_ends_with: String
  bobBountyVaultBalanceChange_not_ends_with_nocase: String
  bobBountyVaultBalanceChange_: ClearBounty_filter
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  trades_: Trade_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Clear_filter]
  or: [Clear_filter]
}

enum Clear_orderBy {
  id
  aliceInputAmount
  aliceOutputAmount
  bobInputAmount
  bobOutputAmount
  aliceBountyAmount
  bobBountyAmount
  aliceBountyVaultBalanceChange
  aliceBountyVaultBalanceChange__id
  aliceBountyVaultBalanceChange__sender
  aliceBountyVaultBalanceChange__amount
  aliceBountyVaultBalanceChange__oldVaultBalance
  aliceBountyVaultBalanceChange__newVaultBalance
  aliceBountyVaultBalanceChange__timestamp
  bobBountyVaultBalanceChange
  bobBountyVaultBalanceChange__id
  bobBountyVaultBalanceChange__sender
  bobBountyVaultBalanceChange__amount
  bobBountyVaultBalanceChange__oldVaultBalance
  bobBountyVaultBalanceChange__newVaultBalance
  bobBountyVaultBalanceChange__timestamp
  orderbook
  orderbook__id
  trades
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

type ClearBounty implements VaultBalanceChange {
  id: Bytes!

  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!

  """
  The msg.sender of this clear call and owner of the vault
  """
  sender: Bytes!

  """
  The vault that was affected
  """
  vault: Vault!

  """
  The amount that was changed - this is signed
  """
  amount: Bytes!

  """
  The balance of the vault before the change
  """
  oldVaultBalance: Bytes!

  """
  The balance of the vault after the change
  """
  newVaultBalance: Bytes!

  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!

  """
  The transaction in which this balance change was executed
  """
  transaction: Transaction!
}

input ClearBounty_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: Bytes
  amount_not: Bytes
  amount_gt: Bytes
  amount_lt: Bytes
  amount_gte: Bytes
  amount_lte: Bytes
  amount_in: [Bytes!]
  amount_not_in: [Bytes!]
  amount_contains: Bytes
  amount_not_contains: Bytes
  oldVaultBalance: Bytes
  oldVaultBalance_not: Bytes
  oldVaultBalance_gt: Bytes
  oldVaultBalance_lt: Bytes
  oldVaultBalance_gte: Bytes
  oldVaultBalance_lte: Bytes
  oldVaultBalance_in: [Bytes!]
  oldVaultBalance_not_in: [Bytes!]
  oldVaultBalance_contains: Bytes
  oldVaultBalance_not_contains: Bytes
  newVaultBalance: Bytes
  newVaultBalance_not: Bytes
  newVaultBalance_gt: Bytes
  newVaultBalance_lt: Bytes
  newVaultBalance_gte: Bytes
  newVaultBalance_lte: Bytes
  newVaultBalance_in: [Bytes!]
  newVaultBalance_not_in: [Bytes!]
  newVaultBalance_contains: Bytes
  newVaultBalance_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ClearBounty_filter]
  or: [ClearBounty_filter]
}

enum ClearBounty_orderBy {
  id
  orderbook
  orderbook__id
  sender
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
}

type ClearTemporaryData {
  id: Bytes!
  aliceOrderHash: Bytes!
  aliceAddress: Bytes!
  aliceInputVaultId: Bytes!
  aliceInputToken: Bytes!
  aliceOutputVaultId: Bytes!
  aliceOutputToken: Bytes!
  aliceBounty: Bytes!
  bobOrderHash: Bytes!
  bobAddress: Bytes!
  bobInputVaultId: Bytes!
  bobInputToken: Bytes!
  bobOutputVaultId: Bytes!
  bobOutputToken: Bytes!
  bobBounty: Bytes!
}

input ClearTemporaryData_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  aliceOrderHash: Bytes
  aliceOrderHash_not: Bytes
  aliceOrderHash_gt: Bytes
  aliceOrderHash_lt: Bytes
  aliceOrderHash_gte: Bytes
  aliceOrderHash_lte: Bytes
  aliceOrderHash_in: [Bytes!]
  aliceOrderHash_not_in: [Bytes!]
  aliceOrderHash_contains: Bytes
  aliceOrderHash_not_contains: Bytes
  aliceAddress: Bytes
  aliceAddress_not: Bytes
  aliceAddress_gt: Bytes
  aliceAddress_lt: Bytes
  aliceAddress_gte: Bytes
  aliceAddress_lte: Bytes
  aliceAddress_in: [Bytes!]
  aliceAddress_not_in: [Bytes!]
  aliceAddress_contains: Bytes
  aliceAddress_not_contains: Bytes
  aliceInputVaultId: Bytes
  aliceInputVaultId_not: Bytes
  aliceInputVaultId_gt: Bytes
  aliceInputVaultId_lt: Bytes
  aliceInputVaultId_gte: Bytes
  aliceInputVaultId_lte: Bytes
  aliceInputVaultId_in: [Bytes!]
  aliceInputVaultId_not_in: [Bytes!]
  aliceInputVaultId_contains: Bytes
  aliceInputVaultId_not_contains: Bytes
  aliceInputToken: Bytes
  aliceInputToken_not: Bytes
  aliceInputToken_gt: Bytes
  aliceInputToken_lt: Bytes
  aliceInputToken_gte: Bytes
  aliceInputToken_lte: Bytes
  aliceInputToken_in: [Bytes!]
  aliceInputToken_not_in: [Bytes!]
  aliceInputToken_contains: Bytes
  aliceInputToken_not_contains: Bytes
  aliceOutputVaultId: Bytes
  aliceOutputVaultId_not: Bytes
  aliceOutputVaultId_gt: Bytes
  aliceOutputVaultId_lt: Bytes
  aliceOutputVaultId_gte: Bytes
  aliceOutputVaultId_lte: Bytes
  aliceOutputVaultId_in: [Bytes!]
  aliceOutputVaultId_not_in: [Bytes!]
  aliceOutputVaultId_contains: Bytes
  aliceOutputVaultId_not_contains: Bytes
  aliceOutputToken: Bytes
  aliceOutputToken_not: Bytes
  aliceOutputToken_gt: Bytes
  aliceOutputToken_lt: Bytes
  aliceOutputToken_gte: Bytes
  aliceOutputToken_lte: Bytes
  aliceOutputToken_in: [Bytes!]
  aliceOutputToken_not_in: [Bytes!]
  aliceOutputToken_contains: Bytes
  aliceOutputToken_not_contains: Bytes
  aliceBounty: Bytes
  aliceBounty_not: Bytes
  aliceBounty_gt: Bytes
  aliceBounty_lt: Bytes
  aliceBounty_gte: Bytes
  aliceBounty_lte: Bytes
  aliceBounty_in: [Bytes!]
  aliceBounty_not_in: [Bytes!]
  aliceBounty_contains: Bytes
  aliceBounty_not_contains: Bytes
  bobOrderHash: Bytes
  bobOrderHash_not: Bytes
  bobOrderHash_gt: Bytes
  bobOrderHash_lt: Bytes
  bobOrderHash_gte: Bytes
  bobOrderHash_lte: Bytes
  bobOrderHash_in: [Bytes!]
  bobOrderHash_not_in: [Bytes!]
  bobOrderHash_contains: Bytes
  bobOrderHash_not_contains: Bytes
  bobAddress: Bytes
  bobAddress_not: Bytes
  bobAddress_gt: Bytes
  bobAddress_lt: Bytes
  bobAddress_gte: Bytes
  bobAddress_lte: Bytes
  bobAddress_in: [Bytes!]
  bobAddress_not_in: [Bytes!]
  bobAddress_contains: Bytes
  bobAddress_not_contains: Bytes
  bobInputVaultId: Bytes
  bobInputVaultId_not: Bytes
  bobInputVaultId_gt: Bytes
  bobInputVaultId_lt: Bytes
  bobInputVaultId_gte: Bytes
  bobInputVaultId_lte: Bytes
  bobInputVaultId_in: [Bytes!]
  bobInputVaultId_not_in: [Bytes!]
  bobInputVaultId_contains: Bytes
  bobInputVaultId_not_contains: Bytes
  bobInputToken: Bytes
  bobInputToken_not: Bytes
  bobInputToken_gt: Bytes
  bobInputToken_lt: Bytes
  bobInputToken_gte: Bytes
  bobInputToken_lte: Bytes
  bobInputToken_in: [Bytes!]
  bobInputToken_not_in: [Bytes!]
  bobInputToken_contains: Bytes
  bobInputToken_not_contains: Bytes
  bobOutputVaultId: Bytes
  bobOutputVaultId_not: Bytes
  bobOutputVaultId_gt: Bytes
  bobOutputVaultId_lt: Bytes
  bobOutputVaultId_gte: Bytes
  bobOutputVaultId_lte: Bytes
  bobOutputVaultId_in: [Bytes!]
  bobOutputVaultId_not_in: [Bytes!]
  bobOutputVaultId_contains: Bytes
  bobOutputVaultId_not_contains: Bytes
  bobOutputToken: Bytes
  bobOutputToken_not: Bytes
  bobOutputToken_gt: Bytes
  bobOutputToken_lt: Bytes
  bobOutputToken_gte: Bytes
  bobOutputToken_lte: Bytes
  bobOutputToken_in: [Bytes!]
  bobOutputToken_not_in: [Bytes!]
  bobOutputToken_contains: Bytes
  bobOutputToken_not_contains: Bytes
  bobBounty: Bytes
  bobBounty_not: Bytes
  bobBounty_gt: Bytes
  bobBounty_lt: Bytes
  bobBounty_gte: Bytes
  bobBounty_lte: Bytes
  bobBounty_in: [Bytes!]
  bobBounty_not_in: [Bytes!]
  bobBounty_contains: Bytes
  bobBounty_not_contains: Bytes

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ClearTemporaryData_filter]
  or: [ClearTemporaryData_filter]
}

enum ClearTemporaryData_orderBy {
  id
  aliceOrderHash
  aliceAddress
  aliceInputVaultId
  aliceInputToken
  aliceOutputVaultId
  aliceOutputToken
  aliceBounty
  bobOrderHash
  bobAddress
  bobInputVaultId
  bobInputToken
  bobOutputVaultId
  bobOutputToken
  bobBounty
}

type Deposit implements Event & VaultBalanceChange {
  id: Bytes!

  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!

  """
  The vault that was deposited into
  """
  vault: Vault!

  """
  The amount that was deposited
  """
  amount: Bytes!
  oldVaultBalance: Bytes!
  newVaultBalance: Bytes!

  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!
  transaction: Transaction!

  """
  The msg.sender of this withdrawal
  """
  sender: Bytes!
}

input Deposit_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: Bytes
  amount_not: Bytes
  amount_gt: Bytes
  amount_lt: Bytes
  amount_gte: Bytes
  amount_lte: Bytes
  amount_in: [Bytes!]
  amount_not_in: [Bytes!]
  amount_contains: Bytes
  amount_not_contains: Bytes
  oldVaultBalance: Bytes
  oldVaultBalance_not: Bytes
  oldVaultBalance_gt: Bytes
  oldVaultBalance_lt: Bytes
  oldVaultBalance_gte: Bytes
  oldVaultBalance_lte: Bytes
  oldVaultBalance_in: [Bytes!]
  oldVaultBalance_not_in: [Bytes!]
  oldVaultBalance_contains: Bytes
  oldVaultBalance_not_contains: Bytes
  newVaultBalance: Bytes
  newVaultBalance_not: Bytes
  newVaultBalance_gt: Bytes
  newVaultBalance_lt: Bytes
  newVaultBalance_gte: Bytes
  newVaultBalance_lte: Bytes
  newVaultBalance_in: [Bytes!]
  newVaultBalance_not_in: [Bytes!]
  newVaultBalance_contains: Bytes
  newVaultBalance_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Deposit_filter]
  or: [Deposit_filter]
}

enum Deposit_orderBy {
  id
  orderbook
  orderbook__id
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

type ERC20 {
  id: Bytes!

  """
  The address of the ERC20 token
  """
  address: Bytes!

  """
  The name of the ERC20 token
  """
  name: String

  """
  The symbol of the ERC20 token
  """
  symbol: String

  """
  The number of decimals of the ERC20 token
  """
  decimals: BigInt
}

input ERC20_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ERC20_filter]
  or: [ERC20_filter]
}

enum ERC20_orderBy {
  id
  address
  name
  symbol
  decimals
}

interface Event {
  """
  Transaction this event was emitted in
  """
  transaction: Transaction!

  """
  msg.sender for the event
  """
  sender: Bytes!
}

input Event_filter {
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Event_filter]
  or: [Event_filter]
}

enum Event_orderBy {
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

"""
8 bytes signed integer
"""
scalar Int8

type Order {
  id: Bytes!

  """
  The orderbook this order is in
  """
  orderbook: Orderbook!

  """
  Whether this order is active or not
  """
  active: Boolean!

  """
  The hash of the order
  """
  orderHash: Bytes!

  """
  The owner of the order
  """
  owner: Bytes!

  """
  The vaults that are inputs to this order
  """
  inputs(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter
  ): [Vault!]!

  """
  The vaults that are outputs to this order
  """
  outputs(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter
  ): [Vault!]!

  """
  A nonce for this order
  """
  nonce: Bytes!

  """
  The ABI encoded bytes for the Order struct
  """
  orderBytes: Bytes!

  """
  AddOrder events for this order
  """
  addEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AddOrder_orderBy
    orderDirection: OrderDirection
    where: AddOrder_filter
  ): [AddOrder!]!

  """
  RemoveOrder events for this order
  """
  removeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveOrder_orderBy
    orderDirection: OrderDirection
    where: RemoveOrder_filter
  ): [RemoveOrder!]!

  """
  Trades for this order
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]!

  """
  Meta emitted for this order
  """
  meta: Bytes

  """
  The timestamp this order was first added
  """
  timestampAdded: BigInt!
}

input Order_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  active: Boolean
  active_not: Boolean
  active_in: [Boolean!]
  active_not_in: [Boolean!]
  orderHash: Bytes
  orderHash_not: Bytes
  orderHash_gt: Bytes
  orderHash_lt: Bytes
  orderHash_gte: Bytes
  orderHash_lte: Bytes
  orderHash_in: [Bytes!]
  orderHash_not_in: [Bytes!]
  orderHash_contains: Bytes
  orderHash_not_contains: Bytes
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  inputs: [String!]
  inputs_not: [String!]
  inputs_contains: [String!]
  inputs_contains_nocase: [String!]
  inputs_not_contains: [String!]
  inputs_not_contains_nocase: [String!]
  inputs_: Vault_filter
  outputs: [String!]
  outputs_not: [String!]
  outputs_contains: [String!]
  outputs_contains_nocase: [String!]
  outputs_not_contains: [String!]
  outputs_not_contains_nocase: [String!]
  outputs_: Vault_filter
  nonce: Bytes
  nonce_not: Bytes
  nonce_gt: Bytes
  nonce_lt: Bytes
  nonce_gte: Bytes
  nonce_lte: Bytes
  nonce_in: [Bytes!]
  nonce_not_in: [Bytes!]
  nonce_contains: Bytes
  nonce_not_contains: Bytes
  orderBytes: Bytes
  orderBytes_not: Bytes
  orderBytes_gt: Bytes
  orderBytes_lt: Bytes
  orderBytes_gte: Bytes
  orderBytes_lte: Bytes
  orderBytes_in: [Bytes!]
  orderBytes_not_in: [Bytes!]
  orderBytes_contains: Bytes
  orderBytes_not_contains: Bytes
  addEvents_: AddOrder_filter
  removeEvents_: RemoveOrder_filter
  trades_: Trade_filter
  meta: Bytes
  meta_not: Bytes
  meta_gt: Bytes
  meta_lt: Bytes
  meta_gte: Bytes
  meta_lte: Bytes
  meta_in: [Bytes!]
  meta_not_in: [Bytes!]
  meta_contains: Bytes
  meta_not_contains: Bytes
  timestampAdded: BigInt
  timestampAdded_not: BigInt
  timestampAdded_gt: BigInt
  timestampAdded_lt: BigInt
  timestampAdded_gte: BigInt
  timestampAdded_lte: BigInt
  timestampAdded_in: [BigInt!]
  timestampAdded_not_in: [BigInt!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Order_filter]
  or: [Order_filter]
}

enum Order_orderBy {
  id
  orderbook
  orderbook__id
  active
  orderHash
  owner
  inputs
  outputs
  nonce
  orderBytes
  addEvents
  removeEvents
  trades
  meta
  timestampAdded
}

type Orderbook {
  id: Bytes!

  """
  All orders in the orderbook
  """
  orders(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
  ): [Order!]!

  """
  All trades in the orderbook
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]!

  """
  All vaults in the orderbook
  """
  vaults(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter
  ): [Vault!]!

  """
  All vault balance changes in the orderbook
  """
  vaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: VaultBalanceChange_filter
  ): [VaultBalanceChange!]!

  """
  All deposit events in the orderbook
  """
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
  ): [Deposit!]!

  """
  All withdrawal events in the orderbook
  """
  withdrawals(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    where: Withdrawal_filter
  ): [Withdrawal!]!

  """
  All add order events in the orderbook
  """
  addOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: AddOrder_orderBy
    orderDirection: OrderDirection
    where: AddOrder_filter
  ): [AddOrder!]!

  """
  All remove order events in the orderbook
  """
  removeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveOrder_orderBy
    orderDirection: OrderDirection
    where: RemoveOrder_filter
  ): [RemoveOrder!]!

  """
  All take order events in the orderbook
  """
  takeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: TakeOrder_orderBy
    orderDirection: OrderDirection
    where: TakeOrder_filter
  ): [TakeOrder!]!

  """
  All trade events in the orderbook
  """
  tradeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeEvent_orderBy
    orderDirection: OrderDirection
    where: TradeEvent_filter
  ): [TradeEvent!]!
}

input Orderbook_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orders_: Order_filter
  trades_: Trade_filter
  vaults_: Vault_filter
  vaultBalanceChanges_: VaultBalanceChange_filter
  deposits_: Deposit_filter
  withdrawals_: Withdrawal_filter
  addOrders_: AddOrder_filter
  removeOrders_: RemoveOrder_filter
  takeOrders_: TakeOrder_filter
  tradeEvents_: TradeEvent_filter

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Orderbook_filter]
  or: [Orderbook_filter]
}

enum Orderbook_orderBy {
  id
  orders
  trades
  vaults
  vaultBalanceChanges
  deposits
  withdrawals
  addOrders
  removeOrders
  takeOrders
  tradeEvents
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type Query {
  orderbook(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Orderbook
  orderbooks(
    skip: Int = 0
    first: Int = 100
    orderBy: Orderbook_orderBy
    orderDirection: OrderDirection
    where: Orderbook_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Orderbook!]!
  vault(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaults(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vault!]!
  deposit(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  withdrawal(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    where: Withdrawal_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawal!]!
  tradeVaultBalanceChange(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeVaultBalanceChange
  tradeVaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeVaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: TradeVaultBalanceChange_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeVaultBalanceChange!]!
  clearBounty(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClearBounty
  clearBounties(
    skip: Int = 0
    first: Int = 100
    orderBy: ClearBounty_orderBy
    orderDirection: OrderDirection
    where: ClearBounty_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClearBounty!]!
  order(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Order
  orders(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Order!]!
  addOrder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddOrder
  addOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: AddOrder_orderBy
    orderDirection: OrderDirection
    where: AddOrder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AddOrder!]!
  removeOrder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveOrder
  removeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveOrder_orderBy
    orderDirection: OrderDirection
    where: RemoveOrder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RemoveOrder!]!
  trade(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  takeOrder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TakeOrder
  takeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: TakeOrder_orderBy
    orderDirection: OrderDirection
    where: TakeOrder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TakeOrder!]!
  clear(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Clear
  clears(
    skip: Int = 0
    first: Int = 100
    orderBy: Clear_orderBy
    orderDirection: OrderDirection
    where: Clear_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Clear!]!
  transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  erc20(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20
  erc20S(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20_orderBy
    orderDirection: OrderDirection
    where: ERC20_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20!]!
  clearTemporaryData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClearTemporaryData
  clearTemporaryDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ClearTemporaryData_orderBy
    orderDirection: OrderDirection
    where: ClearTemporaryData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClearTemporaryData!]!
  vaultBalanceChange(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultBalanceChange
  vaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: VaultBalanceChange_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VaultBalanceChange!]!
  tradeEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeEvent
  tradeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeEvent_orderBy
    orderDirection: OrderDirection
    where: TradeEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeEvent!]!
  event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!

  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

type RemoveOrder implements Event {
  id: Bytes!

  """
  The order that was removed
  """
  order: Order!

  """
  The orderbook this remove order event is in
  """
  orderbook: Orderbook!
  transaction: Transaction!

  """
  The msg.sender of this remove order call
  """
  sender: Bytes!
}

input RemoveOrder_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  order: String
  order_not: String
  order_gt: String
  order_lt: String
  order_gte: String
  order_lte: String
  order_in: [String!]
  order_not_in: [String!]
  order_contains: String
  order_contains_nocase: String
  order_not_contains: String
  order_not_contains_nocase: String
  order_starts_with: String
  order_starts_with_nocase: String
  order_not_starts_with: String
  order_not_starts_with_nocase: String
  order_ends_with: String
  order_ends_with_nocase: String
  order_not_ends_with: String
  order_not_ends_with_nocase: String
  order_: Order_filter
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RemoveOrder_filter]
  or: [RemoveOrder_filter]
}

enum RemoveOrder_orderBy {
  id
  order
  order__id
  order__active
  order__orderHash
  order__owner
  order__nonce
  order__orderBytes
  order__meta
  order__timestampAdded
  orderbook
  orderbook__id
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

type Subscription {
  orderbook(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Orderbook
  orderbooks(
    skip: Int = 0
    first: Int = 100
    orderBy: Orderbook_orderBy
    orderDirection: OrderDirection
    where: Orderbook_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Orderbook!]!
  vault(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaults(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vault!]!
  deposit(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  withdrawal(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    where: Withdrawal_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawal!]!
  tradeVaultBalanceChange(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeVaultBalanceChange
  tradeVaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeVaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: TradeVaultBalanceChange_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeVaultBalanceChange!]!
  clearBounty(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClearBounty
  clearBounties(
    skip: Int = 0
    first: Int = 100
    orderBy: ClearBounty_orderBy
    orderDirection: OrderDirection
    where: ClearBounty_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClearBounty!]!
  order(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Order
  orders(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Order!]!
  addOrder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddOrder
  addOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: AddOrder_orderBy
    orderDirection: OrderDirection
    where: AddOrder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AddOrder!]!
  removeOrder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveOrder
  removeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveOrder_orderBy
    orderDirection: OrderDirection
    where: RemoveOrder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RemoveOrder!]!
  trade(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  takeOrder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TakeOrder
  takeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: TakeOrder_orderBy
    orderDirection: OrderDirection
    where: TakeOrder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TakeOrder!]!
  clear(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Clear
  clears(
    skip: Int = 0
    first: Int = 100
    orderBy: Clear_orderBy
    orderDirection: OrderDirection
    where: Clear_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Clear!]!
  transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  erc20(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20
  erc20S(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20_orderBy
    orderDirection: OrderDirection
    where: ERC20_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20!]!
  clearTemporaryData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClearTemporaryData
  clearTemporaryDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ClearTemporaryData_orderBy
    orderDirection: OrderDirection
    where: ClearTemporaryData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClearTemporaryData!]!
  vaultBalanceChange(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultBalanceChange
  vaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: VaultBalanceChange_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VaultBalanceChange!]!
  tradeEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeEvent
  tradeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeEvent_orderBy
    orderDirection: OrderDirection
    where: TradeEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeEvent!]!
  event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!

  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

type TakeOrder implements TradeEvent {
  id: Bytes!

  """
  The input amount from the perspective of the taker
  """
  inputAmount: Bytes!

  """
  The output amount from the perspective of the taker
  """
  outputAmount: Bytes!

  """
  The ABI encoded bytes for the TakeOrderConfig struct
  """
  takeOrderConfigBytes: Bytes!

  """
  The orderbook this trade event is for
  """
  orderbook: Orderbook!

  """
  The trades that occured in this event
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]!
  transaction: Transaction!

  """
  The msg.sender of this trade
  """
  sender: Bytes!
}

input TakeOrder_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  inputAmount: Bytes
  inputAmount_not: Bytes
  inputAmount_gt: Bytes
  inputAmount_lt: Bytes
  inputAmount_gte: Bytes
  inputAmount_lte: Bytes
  inputAmount_in: [Bytes!]
  inputAmount_not_in: [Bytes!]
  inputAmount_contains: Bytes
  inputAmount_not_contains: Bytes
  outputAmount: Bytes
  outputAmount_not: Bytes
  outputAmount_gt: Bytes
  outputAmount_lt: Bytes
  outputAmount_gte: Bytes
  outputAmount_lte: Bytes
  outputAmount_in: [Bytes!]
  outputAmount_not_in: [Bytes!]
  outputAmount_contains: Bytes
  outputAmount_not_contains: Bytes
  takeOrderConfigBytes: Bytes
  takeOrderConfigBytes_not: Bytes
  takeOrderConfigBytes_gt: Bytes
  takeOrderConfigBytes_lt: Bytes
  takeOrderConfigBytes_gte: Bytes
  takeOrderConfigBytes_lte: Bytes
  takeOrderConfigBytes_in: [Bytes!]
  takeOrderConfigBytes_not_in: [Bytes!]
  takeOrderConfigBytes_contains: Bytes
  takeOrderConfigBytes_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  trades_: Trade_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TakeOrder_filter]
  or: [TakeOrder_filter]
}

enum TakeOrder_orderBy {
  id
  inputAmount
  outputAmount
  takeOrderConfigBytes
  orderbook
  orderbook__id
  trades
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

"""
A string representation of microseconds UNIX timestamp (16 digits)
"""
scalar Timestamp

type Trade {
  id: Bytes!

  """
  The orderbook this trade is for
  """
  orderbook: Orderbook!

  """
  The order that was traded
  """
  order: Order!

  """
  Input vault balance change
  """
  inputVaultBalanceChange: TradeVaultBalanceChange!

  """
  Output vault balance change
  """
  outputVaultBalanceChange: TradeVaultBalanceChange!

  """
  The event in which this trade occured
  """
  tradeEvent: TradeEvent!

  """
  The timestamp this trade was executed
  """
  timestamp: BigInt!
}

input Trade_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  order: String
  order_not: String
  order_gt: String
  order_lt: String
  order_gte: String
  order_lte: String
  order_in: [String!]
  order_not_in: [String!]
  order_contains: String
  order_contains_nocase: String
  order_not_contains: String
  order_not_contains_nocase: String
  order_starts_with: String
  order_starts_with_nocase: String
  order_not_starts_with: String
  order_not_starts_with_nocase: String
  order_ends_with: String
  order_ends_with_nocase: String
  order_not_ends_with: String
  order_not_ends_with_nocase: String
  order_: Order_filter
  inputVaultBalanceChange: String
  inputVaultBalanceChange_not: String
  inputVaultBalanceChange_gt: String
  inputVaultBalanceChange_lt: String
  inputVaultBalanceChange_gte: String
  inputVaultBalanceChange_lte: String
  inputVaultBalanceChange_in: [String!]
  inputVaultBalanceChange_not_in: [String!]
  inputVaultBalanceChange_contains: String
  inputVaultBalanceChange_contains_nocase: String
  inputVaultBalanceChange_not_contains: String
  inputVaultBalanceChange_not_contains_nocase: String
  inputVaultBalanceChange_starts_with: String
  inputVaultBalanceChange_starts_with_nocase: String
  inputVaultBalanceChange_not_starts_with: String
  inputVaultBalanceChange_not_starts_with_nocase: String
  inputVaultBalanceChange_ends_with: String
  inputVaultBalanceChange_ends_with_nocase: String
  inputVaultBalanceChange_not_ends_with: String
  inputVaultBalanceChange_not_ends_with_nocase: String
  inputVaultBalanceChange_: TradeVaultBalanceChange_filter
  outputVaultBalanceChange: String
  outputVaultBalanceChange_not: String
  outputVaultBalanceChange_gt: String
  outputVaultBalanceChange_lt: String
  outputVaultBalanceChange_gte: String
  outputVaultBalanceChange_lte: String
  outputVaultBalanceChange_in: [String!]
  outputVaultBalanceChange_not_in: [String!]
  outputVaultBalanceChange_contains: String
  outputVaultBalanceChange_contains_nocase: String
  outputVaultBalanceChange_not_contains: String
  outputVaultBalanceChange_not_contains_nocase: String
  outputVaultBalanceChange_starts_with: String
  outputVaultBalanceChange_starts_with_nocase: String
  outputVaultBalanceChange_not_starts_with: String
  outputVaultBalanceChange_not_starts_with_nocase: String
  outputVaultBalanceChange_ends_with: String
  outputVaultBalanceChange_ends_with_nocase: String
  outputVaultBalanceChange_not_ends_with: String
  outputVaultBalanceChange_not_ends_with_nocase: String
  outputVaultBalanceChange_: TradeVaultBalanceChange_filter
  tradeEvent: String
  tradeEvent_not: String
  tradeEvent_gt: String
  tradeEvent_lt: String
  tradeEvent_gte: String
  tradeEvent_lte: String
  tradeEvent_in: [String!]
  tradeEvent_not_in: [String!]
  tradeEvent_contains: String
  tradeEvent_contains_nocase: String
  tradeEvent_not_contains: String
  tradeEvent_not_contains_nocase: String
  tradeEvent_starts_with: String
  tradeEvent_starts_with_nocase: String
  tradeEvent_not_starts_with: String
  tradeEvent_not_starts_with_nocase: String
  tradeEvent_ends_with: String
  tradeEvent_ends_with_nocase: String
  tradeEvent_not_ends_with: String
  tradeEvent_not_ends_with_nocase: String
  tradeEvent_: TradeEvent_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Trade_filter]
  or: [Trade_filter]
}

enum Trade_orderBy {
  id
  orderbook
  orderbook__id
  order
  order__id
  order__active
  order__orderHash
  order__owner
  order__nonce
  order__orderBytes
  order__meta
  order__timestampAdded
  inputVaultBalanceChange
  inputVaultBalanceChange__id
  inputVaultBalanceChange__amount
  inputVaultBalanceChange__oldVaultBalance
  inputVaultBalanceChange__newVaultBalance
  inputVaultBalanceChange__timestamp
  outputVaultBalanceChange
  outputVaultBalanceChange__id
  outputVaultBalanceChange__amount
  outputVaultBalanceChange__oldVaultBalance
  outputVaultBalanceChange__newVaultBalance
  outputVaultBalanceChange__timestamp
  tradeEvent
  tradeEvent__id
  tradeEvent__sender
  timestamp
}

interface TradeEvent {
  id: Bytes!

  """
  The orderbook this trade event is for
  """
  orderbook: Orderbook!

  """
  The trades that occured in this event
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]!
  transaction: Transaction!

  """
  The msg.sender of this trade
  """
  sender: Bytes!
}

input TradeEvent_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  trades_: Trade_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TradeEvent_filter]
  or: [TradeEvent_filter]
}

enum TradeEvent_orderBy {
  id
  orderbook
  orderbook__id
  trades
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

type TradeVaultBalanceChange implements VaultBalanceChange {
  id: Bytes!

  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!

  """
  The trade that this balance change is for
  """
  trade: Trade!

  """
  The vault that was affected
  """
  vault: Vault!

  """
  The amount that was changed - this is signed
  """
  amount: Bytes!

  """
  The balance of the vault before the change
  """
  oldVaultBalance: Bytes!

  """
  The balance of the vault after the change
  """
  newVaultBalance: Bytes!

  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!

  """
  The transaction in which this balance change was executed
  """
  transaction: Transaction!
}

input TradeVaultBalanceChange_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  trade: String
  trade_not: String
  trade_gt: String
  trade_lt: String
  trade_gte: String
  trade_lte: String
  trade_in: [String!]
  trade_not_in: [String!]
  trade_contains: String
  trade_contains_nocase: String
  trade_not_contains: String
  trade_not_contains_nocase: String
  trade_starts_with: String
  trade_starts_with_nocase: String
  trade_not_starts_with: String
  trade_not_starts_with_nocase: String
  trade_ends_with: String
  trade_ends_with_nocase: String
  trade_not_ends_with: String
  trade_not_ends_with_nocase: String
  trade_: Trade_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: Bytes
  amount_not: Bytes
  amount_gt: Bytes
  amount_lt: Bytes
  amount_gte: Bytes
  amount_lte: Bytes
  amount_in: [Bytes!]
  amount_not_in: [Bytes!]
  amount_contains: Bytes
  amount_not_contains: Bytes
  oldVaultBalance: Bytes
  oldVaultBalance_not: Bytes
  oldVaultBalance_gt: Bytes
  oldVaultBalance_lt: Bytes
  oldVaultBalance_gte: Bytes
  oldVaultBalance_lte: Bytes
  oldVaultBalance_in: [Bytes!]
  oldVaultBalance_not_in: [Bytes!]
  oldVaultBalance_contains: Bytes
  oldVaultBalance_not_contains: Bytes
  newVaultBalance: Bytes
  newVaultBalance_not: Bytes
  newVaultBalance_gt: Bytes
  newVaultBalance_lt: Bytes
  newVaultBalance_gte: Bytes
  newVaultBalance_lte: Bytes
  newVaultBalance_in: [Bytes!]
  newVaultBalance_not_in: [Bytes!]
  newVaultBalance_contains: Bytes
  newVaultBalance_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TradeVaultBalanceChange_filter]
  or: [TradeVaultBalanceChange_filter]
}

enum TradeVaultBalanceChange_orderBy {
  id
  orderbook
  orderbook__id
  trade
  trade__id
  trade__timestamp
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
}

type Transaction {
  id: Bytes!
  timestamp: BigInt!
  blockNumber: BigInt!
  from: Bytes!
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter
  ): [Event!]
}

input Transaction_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  events_: Event_filter

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Transaction_filter]
  or: [Transaction_filter]
}

enum Transaction_orderBy {
  id
  timestamp
  blockNumber
  from
  events
}

type Vault {
  id: Bytes!

  """
  The orderbook this vault is in
  """
  orderbook: Orderbook!

  """
  The token that this vault is for
  """
  token: ERC20!

  """
  The owner of this vault
  """
  owner: Bytes!

  """
  The vaultId of this vault
  """
  vaultId: Bytes!

  """
  Orders this vault is an input for
  """
  ordersAsInput(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
  ): [Order!]!

  """
  Orders this vault is an output for
  """
  ordersAsOutput(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
  ): [Order!]!

  """
  The amount of the token that is in this vault
  """
  balance: Bytes!

  """
  All balance changes for this vault
  """
  balanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: VaultBalanceChange_filter
  ): [VaultBalanceChange!]!
}

input Vault_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: ERC20_filter
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  vaultId: Bytes
  vaultId_not: Bytes
  vaultId_gt: Bytes
  vaultId_lt: Bytes
  vaultId_gte: Bytes
  vaultId_lte: Bytes
  vaultId_in: [Bytes!]
  vaultId_not_in: [Bytes!]
  vaultId_contains: Bytes
  vaultId_not_contains: Bytes
  ordersAsInput_: Order_filter
  ordersAsOutput_: Order_filter
  balance: Bytes
  balance_not: Bytes
  balance_gt: Bytes
  balance_lt: Bytes
  balance_gte: Bytes
  balance_lte: Bytes
  balance_in: [Bytes!]
  balance_not_in: [Bytes!]
  balance_contains: Bytes
  balance_not_contains: Bytes
  balanceChanges_: VaultBalanceChange_filter

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Vault_filter]
  or: [Vault_filter]
}

enum Vault_orderBy {
  id
  orderbook
  orderbook__id
  token
  token__id
  token__address
  token__name
  token__symbol
  token__decimals
  owner
  vaultId
  ordersAsInput
  ordersAsOutput
  balance
  balanceChanges
}

interface VaultBalanceChange {
  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!

  """
  The vault that was affected
  """
  vault: Vault!

  """
  The amount changed - this is signed
  """
  amount: Bytes!

  """
  The balance of the vault before the change
  """
  oldVaultBalance: Bytes!

  """
  The balance of the vault after the change
  """
  newVaultBalance: Bytes!

  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!

  """
  The transaction in which this balance change was executed
  """
  transaction: Transaction!
}

input VaultBalanceChange_filter {
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: Bytes
  amount_not: Bytes
  amount_gt: Bytes
  amount_lt: Bytes
  amount_gte: Bytes
  amount_lte: Bytes
  amount_in: [Bytes!]
  amount_not_in: [Bytes!]
  amount_contains: Bytes
  amount_not_contains: Bytes
  oldVaultBalance: Bytes
  oldVaultBalance_not: Bytes
  oldVaultBalance_gt: Bytes
  oldVaultBalance_lt: Bytes
  oldVaultBalance_gte: Bytes
  oldVaultBalance_lte: Bytes
  oldVaultBalance_in: [Bytes!]
  oldVaultBalance_not_in: [Bytes!]
  oldVaultBalance_contains: Bytes
  oldVaultBalance_not_contains: Bytes
  newVaultBalance: Bytes
  newVaultBalance_not: Bytes
  newVaultBalance_gt: Bytes
  newVaultBalance_lt: Bytes
  newVaultBalance_gte: Bytes
  newVaultBalance_lte: Bytes
  newVaultBalance_in: [Bytes!]
  newVaultBalance_not_in: [Bytes!]
  newVaultBalance_contains: Bytes
  newVaultBalance_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [VaultBalanceChange_filter]
  or: [VaultBalanceChange_filter]
}

enum VaultBalanceChange_orderBy {
  orderbook
  orderbook__id
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
}

type Withdrawal implements Event & VaultBalanceChange {
  id: Bytes!

  """
  The amount that was being targeted to be withdrawn
  """
  targetAmount: Bytes!

  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!

  """
  The vault that was withdrawn from
  """
  vault: Vault!

  """
  The amount that was actually withdrawn - this will be negative
  """
  amount: Bytes!
  oldVaultBalance: Bytes!
  newVaultBalance: Bytes!

  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!
  transaction: Transaction!

  """
  The msg.sender of this withdrawal
  """
  sender: Bytes!
}

input Withdrawal_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  targetAmount: Bytes
  targetAmount_not: Bytes
  targetAmount_gt: Bytes
  targetAmount_lt: Bytes
  targetAmount_gte: Bytes
  targetAmount_lte: Bytes
  targetAmount_in: [Bytes!]
  targetAmount_not_in: [Bytes!]
  targetAmount_contains: Bytes
  targetAmount_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: Bytes
  amount_not: Bytes
  amount_gt: Bytes
  amount_lt: Bytes
  amount_gte: Bytes
  amount_lte: Bytes
  amount_in: [Bytes!]
  amount_not_in: [Bytes!]
  amount_contains: Bytes
  amount_not_contains: Bytes
  oldVaultBalance: Bytes
  oldVaultBalance_not: Bytes
  oldVaultBalance_gt: Bytes
  oldVaultBalance_lt: Bytes
  oldVaultBalance_gte: Bytes
  oldVaultBalance_lte: Bytes
  oldVaultBalance_in: [Bytes!]
  oldVaultBalance_not_in: [Bytes!]
  oldVaultBalance_contains: Bytes
  oldVaultBalance_not_contains: Bytes
  newVaultBalance: Bytes
  newVaultBalance_not: Bytes
  newVaultBalance_gt: Bytes
  newVaultBalance_lt: Bytes
  newVaultBalance_gte: Bytes
  newVaultBalance_lte: Bytes
  newVaultBalance_in: [Bytes!]
  newVaultBalance_not_in: [Bytes!]
  newVaultBalance_contains: Bytes
  newVaultBalance_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Withdrawal_filter]
  or: [Withdrawal_filter]
}

enum Withdrawal_orderBy {
  id
  targetAmount
  orderbook
  orderbook__id
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}
