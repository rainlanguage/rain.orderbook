type AddOrder implements Event {
  id: Bytes!
  """
  The order that was added
  """
  order: Order!
  """
  The orderbook this add order event is in
  """
  orderbook: Orderbook!
  transaction: Transaction!
  """
  The msg.sender of this add order call
  """
  sender: Bytes!
}

input AddOrder_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  order: String
  order_not: String
  order_gt: String
  order_lt: String
  order_gte: String
  order_lte: String
  order_in: [String!]
  order_not_in: [String!]
  order_contains: String
  order_contains_nocase: String
  order_not_contains: String
  order_not_contains_nocase: String
  order_starts_with: String
  order_starts_with_nocase: String
  order_not_starts_with: String
  order_not_starts_with_nocase: String
  order_ends_with: String
  order_ends_with_nocase: String
  order_not_ends_with: String
  order_not_ends_with_nocase: String
  order_: Order_filter
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [AddOrder_filter]
  or: [AddOrder_filter]
}

enum AddOrder_orderBy {
  id
  order
  order__id
  order__active
  order__orderHash
  order__owner
  order__nonce
  order__orderBytes
  order__meta
  order__timestampAdded
  orderbook
  orderbook__id
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type ClearBounty implements VaultBalanceChange {
  id: Bytes!
  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!
  """
  The msg.sender of this clear call and owner of the vault
  """
  sender: Bytes!
  """
  The vault that was affected
  """
  vault: Vault!
  """
  The amount that was changed - this is signed
  """
  amount: BigInt!
  """
  The balance of the vault before the change
  """
  oldVaultBalance: BigInt!
  """
  The balance of the vault after the change
  """
  newVaultBalance: BigInt!
  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!
  """
  The transaction in which this balance change was executed
  """
  transaction: Transaction!
}

input ClearBounty_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  oldVaultBalance: BigInt
  oldVaultBalance_not: BigInt
  oldVaultBalance_gt: BigInt
  oldVaultBalance_lt: BigInt
  oldVaultBalance_gte: BigInt
  oldVaultBalance_lte: BigInt
  oldVaultBalance_in: [BigInt!]
  oldVaultBalance_not_in: [BigInt!]
  newVaultBalance: BigInt
  newVaultBalance_not: BigInt
  newVaultBalance_gt: BigInt
  newVaultBalance_lt: BigInt
  newVaultBalance_gte: BigInt
  newVaultBalance_lte: BigInt
  newVaultBalance_in: [BigInt!]
  newVaultBalance_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ClearBounty_filter]
  or: [ClearBounty_filter]
}

enum ClearBounty_orderBy {
  id
  orderbook
  orderbook__id
  sender
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
}

type ClearTemporaryData {
  id: Bytes!
  aliceOrderHash: Bytes!
  aliceAddress: Bytes!
  aliceInputVaultId: BigInt!
  aliceInputToken: Bytes!
  aliceOutputVaultId: BigInt!
  aliceOutputToken: Bytes!
  aliceBounty: BigInt!
  bobOrderHash: Bytes!
  bobAddress: Bytes!
  bobInputVaultId: BigInt!
  bobInputToken: Bytes!
  bobOutputVaultId: BigInt!
  bobOutputToken: Bytes!
  bobBounty: BigInt!
}

input ClearTemporaryData_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  aliceOrderHash: Bytes
  aliceOrderHash_not: Bytes
  aliceOrderHash_gt: Bytes
  aliceOrderHash_lt: Bytes
  aliceOrderHash_gte: Bytes
  aliceOrderHash_lte: Bytes
  aliceOrderHash_in: [Bytes!]
  aliceOrderHash_not_in: [Bytes!]
  aliceOrderHash_contains: Bytes
  aliceOrderHash_not_contains: Bytes
  aliceAddress: Bytes
  aliceAddress_not: Bytes
  aliceAddress_gt: Bytes
  aliceAddress_lt: Bytes
  aliceAddress_gte: Bytes
  aliceAddress_lte: Bytes
  aliceAddress_in: [Bytes!]
  aliceAddress_not_in: [Bytes!]
  aliceAddress_contains: Bytes
  aliceAddress_not_contains: Bytes
  aliceInputVaultId: BigInt
  aliceInputVaultId_not: BigInt
  aliceInputVaultId_gt: BigInt
  aliceInputVaultId_lt: BigInt
  aliceInputVaultId_gte: BigInt
  aliceInputVaultId_lte: BigInt
  aliceInputVaultId_in: [BigInt!]
  aliceInputVaultId_not_in: [BigInt!]
  aliceInputToken: Bytes
  aliceInputToken_not: Bytes
  aliceInputToken_gt: Bytes
  aliceInputToken_lt: Bytes
  aliceInputToken_gte: Bytes
  aliceInputToken_lte: Bytes
  aliceInputToken_in: [Bytes!]
  aliceInputToken_not_in: [Bytes!]
  aliceInputToken_contains: Bytes
  aliceInputToken_not_contains: Bytes
  aliceOutputVaultId: BigInt
  aliceOutputVaultId_not: BigInt
  aliceOutputVaultId_gt: BigInt
  aliceOutputVaultId_lt: BigInt
  aliceOutputVaultId_gte: BigInt
  aliceOutputVaultId_lte: BigInt
  aliceOutputVaultId_in: [BigInt!]
  aliceOutputVaultId_not_in: [BigInt!]
  aliceOutputToken: Bytes
  aliceOutputToken_not: Bytes
  aliceOutputToken_gt: Bytes
  aliceOutputToken_lt: Bytes
  aliceOutputToken_gte: Bytes
  aliceOutputToken_lte: Bytes
  aliceOutputToken_in: [Bytes!]
  aliceOutputToken_not_in: [Bytes!]
  aliceOutputToken_contains: Bytes
  aliceOutputToken_not_contains: Bytes
  aliceBounty: BigInt
  aliceBounty_not: BigInt
  aliceBounty_gt: BigInt
  aliceBounty_lt: BigInt
  aliceBounty_gte: BigInt
  aliceBounty_lte: BigInt
  aliceBounty_in: [BigInt!]
  aliceBounty_not_in: [BigInt!]
  bobOrderHash: Bytes
  bobOrderHash_not: Bytes
  bobOrderHash_gt: Bytes
  bobOrderHash_lt: Bytes
  bobOrderHash_gte: Bytes
  bobOrderHash_lte: Bytes
  bobOrderHash_in: [Bytes!]
  bobOrderHash_not_in: [Bytes!]
  bobOrderHash_contains: Bytes
  bobOrderHash_not_contains: Bytes
  bobAddress: Bytes
  bobAddress_not: Bytes
  bobAddress_gt: Bytes
  bobAddress_lt: Bytes
  bobAddress_gte: Bytes
  bobAddress_lte: Bytes
  bobAddress_in: [Bytes!]
  bobAddress_not_in: [Bytes!]
  bobAddress_contains: Bytes
  bobAddress_not_contains: Bytes
  bobInputVaultId: BigInt
  bobInputVaultId_not: BigInt
  bobInputVaultId_gt: BigInt
  bobInputVaultId_lt: BigInt
  bobInputVaultId_gte: BigInt
  bobInputVaultId_lte: BigInt
  bobInputVaultId_in: [BigInt!]
  bobInputVaultId_not_in: [BigInt!]
  bobInputToken: Bytes
  bobInputToken_not: Bytes
  bobInputToken_gt: Bytes
  bobInputToken_lt: Bytes
  bobInputToken_gte: Bytes
  bobInputToken_lte: Bytes
  bobInputToken_in: [Bytes!]
  bobInputToken_not_in: [Bytes!]
  bobInputToken_contains: Bytes
  bobInputToken_not_contains: Bytes
  bobOutputVaultId: BigInt
  bobOutputVaultId_not: BigInt
  bobOutputVaultId_gt: BigInt
  bobOutputVaultId_lt: BigInt
  bobOutputVaultId_gte: BigInt
  bobOutputVaultId_lte: BigInt
  bobOutputVaultId_in: [BigInt!]
  bobOutputVaultId_not_in: [BigInt!]
  bobOutputToken: Bytes
  bobOutputToken_not: Bytes
  bobOutputToken_gt: Bytes
  bobOutputToken_lt: Bytes
  bobOutputToken_gte: Bytes
  bobOutputToken_lte: Bytes
  bobOutputToken_in: [Bytes!]
  bobOutputToken_not_in: [Bytes!]
  bobOutputToken_contains: Bytes
  bobOutputToken_not_contains: Bytes
  bobBounty: BigInt
  bobBounty_not: BigInt
  bobBounty_gt: BigInt
  bobBounty_lt: BigInt
  bobBounty_gte: BigInt
  bobBounty_lte: BigInt
  bobBounty_in: [BigInt!]
  bobBounty_not_in: [BigInt!]
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ClearTemporaryData_filter]
  or: [ClearTemporaryData_filter]
}

enum ClearTemporaryData_orderBy {
  id
  aliceOrderHash
  aliceAddress
  aliceInputVaultId
  aliceInputToken
  aliceOutputVaultId
  aliceOutputToken
  aliceBounty
  bobOrderHash
  bobAddress
  bobInputVaultId
  bobInputToken
  bobOutputVaultId
  bobOutputToken
  bobBounty
}

type Deposit implements Event & VaultBalanceChange {
  id: Bytes!
  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!
  """
  The vault that was deposited into
  """
  vault: Vault!
  """
  The amount that was deposited
  """
  amount: BigInt!
  oldVaultBalance: BigInt!
  newVaultBalance: BigInt!
  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!
  transaction: Transaction!
  """
  The msg.sender of this withdrawal
  """
  sender: Bytes!
}

input Deposit_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  oldVaultBalance: BigInt
  oldVaultBalance_not: BigInt
  oldVaultBalance_gt: BigInt
  oldVaultBalance_lt: BigInt
  oldVaultBalance_gte: BigInt
  oldVaultBalance_lte: BigInt
  oldVaultBalance_in: [BigInt!]
  oldVaultBalance_not_in: [BigInt!]
  newVaultBalance: BigInt
  newVaultBalance_not: BigInt
  newVaultBalance_gt: BigInt
  newVaultBalance_lt: BigInt
  newVaultBalance_gte: BigInt
  newVaultBalance_lte: BigInt
  newVaultBalance_in: [BigInt!]
  newVaultBalance_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Deposit_filter]
  or: [Deposit_filter]
}

enum Deposit_orderBy {
  id
  orderbook
  orderbook__id
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

type ERC20 {
  id: Bytes!
  """
  The address of the ERC20 token
  """
  address: Bytes!
  """
  The name of the ERC20 token
  """
  name: String
  """
  The symbol of the ERC20 token
  """
  symbol: String
  """
  The number of decimals of the ERC20 token
  """
  decimals: BigInt
}

input ERC20_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ERC20_filter]
  or: [ERC20_filter]
}

enum ERC20_orderBy {
  id
  address
  name
  symbol
  decimals
}

interface Event {
  """
  Transaction this event was emitted in
  """
  transaction: Transaction!
  """
  msg.sender for the event
  """
  sender: Bytes!
}

input Event_filter {
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Event_filter]
  or: [Event_filter]
}

enum Event_orderBy {
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

"""
8 bytes signed integer

"""
scalar Int8

type Order {
  id: Bytes!
  """
  The orderbook this order is in
  """
  orderbook: Orderbook!
  """
  Whether this order is active or not
  """
  active: Boolean!
  """
  The hash of the order
  """
  orderHash: Bytes!
  """
  The owner of the order
  """
  owner: Bytes!
  """
  The vaults that are inputs to this order
  """
  inputs(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter
  ): [Vault!]!
  """
  The vaults that are outputs to this order
  """
  outputs(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter
  ): [Vault!]!
  """
  A nonce for this order
  """
  nonce: Bytes!
  """
  The ABI encoded bytes for the Order struct
  """
  orderBytes: Bytes!
  """
  AddOrder events for this order
  """
  addEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AddOrder_orderBy
    orderDirection: OrderDirection
    where: AddOrder_filter
  ): [AddOrder!]!
  """
  RemoveOrder events for this order
  """
  removeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveOrder_orderBy
    orderDirection: OrderDirection
    where: RemoveOrder_filter
  ): [RemoveOrder!]!
  """
  Trades for this order
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]!
  """
  Meta emitted for this order
  """
  meta: Bytes
  """
  The timestamp this order was first added
  """
  timestampAdded: BigInt!
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

input Order_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  active: Boolean
  active_not: Boolean
  active_in: [Boolean!]
  active_not_in: [Boolean!]
  orderHash: Bytes
  orderHash_not: Bytes
  orderHash_gt: Bytes
  orderHash_lt: Bytes
  orderHash_gte: Bytes
  orderHash_lte: Bytes
  orderHash_in: [Bytes!]
  orderHash_not_in: [Bytes!]
  orderHash_contains: Bytes
  orderHash_not_contains: Bytes
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  inputs: [String!]
  inputs_not: [String!]
  inputs_contains: [String!]
  inputs_contains_nocase: [String!]
  inputs_not_contains: [String!]
  inputs_not_contains_nocase: [String!]
  inputs_: Vault_filter
  outputs: [String!]
  outputs_not: [String!]
  outputs_contains: [String!]
  outputs_contains_nocase: [String!]
  outputs_not_contains: [String!]
  outputs_not_contains_nocase: [String!]
  outputs_: Vault_filter
  nonce: Bytes
  nonce_not: Bytes
  nonce_gt: Bytes
  nonce_lt: Bytes
  nonce_gte: Bytes
  nonce_lte: Bytes
  nonce_in: [Bytes!]
  nonce_not_in: [Bytes!]
  nonce_contains: Bytes
  nonce_not_contains: Bytes
  orderBytes: Bytes
  orderBytes_not: Bytes
  orderBytes_gt: Bytes
  orderBytes_lt: Bytes
  orderBytes_gte: Bytes
  orderBytes_lte: Bytes
  orderBytes_in: [Bytes!]
  orderBytes_not_in: [Bytes!]
  orderBytes_contains: Bytes
  orderBytes_not_contains: Bytes
  addEvents_: AddOrder_filter
  removeEvents_: RemoveOrder_filter
  trades_: Trade_filter
  meta: Bytes
  meta_not: Bytes
  meta_gt: Bytes
  meta_lt: Bytes
  meta_gte: Bytes
  meta_lte: Bytes
  meta_in: [Bytes!]
  meta_not_in: [Bytes!]
  meta_contains: Bytes
  meta_not_contains: Bytes
  timestampAdded: BigInt
  timestampAdded_not: BigInt
  timestampAdded_gt: BigInt
  timestampAdded_lt: BigInt
  timestampAdded_gte: BigInt
  timestampAdded_lte: BigInt
  timestampAdded_in: [BigInt!]
  timestampAdded_not_in: [BigInt!]
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Order_filter]
  or: [Order_filter]
}

enum Order_orderBy {
  id
  orderbook
  orderbook__id
  active
  orderHash
  owner
  inputs
  outputs
  nonce
  orderBytes
  addEvents
  removeEvents
  trades
  meta
  timestampAdded
}

type Orderbook {
  id: Bytes!
  """
  All orders in the orderbook
  """
  orders(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
  ): [Order!]!
  """
  All trades in the orderbook
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]!
  """
  All vaults in the orderbook
  """
  vaults(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter
  ): [Vault!]!
  """
  All vault balance changes in the orderbook
  """
  vaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: VaultBalanceChange_filter
  ): [VaultBalanceChange!]!
  """
  All deposit events in the orderbook
  """
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
  ): [Deposit!]!
  """
  All withdrawal events in the orderbook
  """
  withdrawals(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    where: Withdrawal_filter
  ): [Withdrawal!]!
  """
  All add order events in the orderbook
  """
  addOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: AddOrder_orderBy
    orderDirection: OrderDirection
    where: AddOrder_filter
  ): [AddOrder!]!
  """
  All remove order events in the orderbook
  """
  removeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveOrder_orderBy
    orderDirection: OrderDirection
    where: RemoveOrder_filter
  ): [RemoveOrder!]!
  """
  All take order events in the orderbook
  """
  takeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: TakeOrder_orderBy
    orderDirection: OrderDirection
    where: TakeOrder_filter
  ): [TakeOrder!]!
  """
  All trade events in the orderbook
  """
  tradeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeEvent_orderBy
    orderDirection: OrderDirection
    where: TradeEvent_filter
  ): [TradeEvent!]!
}

input Orderbook_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orders_: Order_filter
  trades_: Trade_filter
  vaults_: Vault_filter
  vaultBalanceChanges_: VaultBalanceChange_filter
  deposits_: Deposit_filter
  withdrawals_: Withdrawal_filter
  addOrders_: AddOrder_filter
  removeOrders_: RemoveOrder_filter
  takeOrders_: TakeOrder_filter
  tradeEvents_: TradeEvent_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Orderbook_filter]
  or: [Orderbook_filter]
}

enum Orderbook_orderBy {
  id
  orders
  trades
  vaults
  vaultBalanceChanges
  deposits
  withdrawals
  addOrders
  removeOrders
  takeOrders
  tradeEvents
}

type Query {
  orderbook(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Orderbook
  orderbooks(
    skip: Int = 0
    first: Int = 100
    orderBy: Orderbook_orderBy
    orderDirection: OrderDirection
    where: Orderbook_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Orderbook!]!
  vault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaults(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vault!]!
  deposit(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  withdrawal(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    where: Withdrawal_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawal!]!
  tradeVaultBalanceChange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeVaultBalanceChange
  tradeVaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeVaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: TradeVaultBalanceChange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeVaultBalanceChange!]!
  clearBounty(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClearBounty
  clearBounties(
    skip: Int = 0
    first: Int = 100
    orderBy: ClearBounty_orderBy
    orderDirection: OrderDirection
    where: ClearBounty_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClearBounty!]!
  order(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Order
  orders(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Order!]!
  addOrder(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddOrder
  addOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: AddOrder_orderBy
    orderDirection: OrderDirection
    where: AddOrder_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AddOrder!]!
  removeOrder(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveOrder
  removeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveOrder_orderBy
    orderDirection: OrderDirection
    where: RemoveOrder_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RemoveOrder!]!
  trade(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  takeOrder(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TakeOrder
  takeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: TakeOrder_orderBy
    orderDirection: OrderDirection
    where: TakeOrder_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TakeOrder!]!
  transaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  erc20(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20
  erc20S(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20_orderBy
    orderDirection: OrderDirection
    where: ERC20_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20!]!
  clearTemporaryData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClearTemporaryData
  clearTemporaryDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ClearTemporaryData_orderBy
    orderDirection: OrderDirection
    where: ClearTemporaryData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClearTemporaryData!]!
  vaultBalanceChange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultBalanceChange
  vaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: VaultBalanceChange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VaultBalanceChange!]!
  tradeEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeEvent
  tradeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeEvent_orderBy
    orderDirection: OrderDirection
    where: TradeEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeEvent!]!
  event(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

type RemoveOrder implements Event {
  id: Bytes!
  """
  The order that was removed
  """
  order: Order!
  """
  The orderbook this remove order event is in
  """
  orderbook: Orderbook!
  transaction: Transaction!
  """
  The msg.sender of this remove order call
  """
  sender: Bytes!
}

input RemoveOrder_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  order: String
  order_not: String
  order_gt: String
  order_lt: String
  order_gte: String
  order_lte: String
  order_in: [String!]
  order_not_in: [String!]
  order_contains: String
  order_contains_nocase: String
  order_not_contains: String
  order_not_contains_nocase: String
  order_starts_with: String
  order_starts_with_nocase: String
  order_not_starts_with: String
  order_not_starts_with_nocase: String
  order_ends_with: String
  order_ends_with_nocase: String
  order_not_ends_with: String
  order_not_ends_with_nocase: String
  order_: Order_filter
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RemoveOrder_filter]
  or: [RemoveOrder_filter]
}

enum RemoveOrder_orderBy {
  id
  order
  order__id
  order__active
  order__orderHash
  order__owner
  order__nonce
  order__orderBytes
  order__meta
  order__timestampAdded
  orderbook
  orderbook__id
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

type Subscription {
  orderbook(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Orderbook
  orderbooks(
    skip: Int = 0
    first: Int = 100
    orderBy: Orderbook_orderBy
    orderDirection: OrderDirection
    where: Orderbook_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Orderbook!]!
  vault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaults(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vault!]!
  deposit(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  withdrawal(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    where: Withdrawal_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawal!]!
  tradeVaultBalanceChange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeVaultBalanceChange
  tradeVaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeVaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: TradeVaultBalanceChange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeVaultBalanceChange!]!
  clearBounty(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClearBounty
  clearBounties(
    skip: Int = 0
    first: Int = 100
    orderBy: ClearBounty_orderBy
    orderDirection: OrderDirection
    where: ClearBounty_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClearBounty!]!
  order(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Order
  orders(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Order!]!
  addOrder(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddOrder
  addOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: AddOrder_orderBy
    orderDirection: OrderDirection
    where: AddOrder_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AddOrder!]!
  removeOrder(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveOrder
  removeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveOrder_orderBy
    orderDirection: OrderDirection
    where: RemoveOrder_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RemoveOrder!]!
  trade(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  takeOrder(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TakeOrder
  takeOrders(
    skip: Int = 0
    first: Int = 100
    orderBy: TakeOrder_orderBy
    orderDirection: OrderDirection
    where: TakeOrder_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TakeOrder!]!
  transaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  erc20(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20
  erc20S(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20_orderBy
    orderDirection: OrderDirection
    where: ERC20_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20!]!
  clearTemporaryData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClearTemporaryData
  clearTemporaryDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ClearTemporaryData_orderBy
    orderDirection: OrderDirection
    where: ClearTemporaryData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClearTemporaryData!]!
  vaultBalanceChange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultBalanceChange
  vaultBalanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: VaultBalanceChange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VaultBalanceChange!]!
  tradeEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradeEvent
  tradeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TradeEvent_orderBy
    orderDirection: OrderDirection
    where: TradeEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TradeEvent!]!
  event(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

type TakeOrder implements TradeEvent {
  id: Bytes!
  """
  The input amount from the perspective of the taker
  """
  inputAmount: BigInt!
  """
  The output amount from the perspective of the taker
  """
  outputAmount: BigInt!
  """
  The ABI encoded bytes for the TakeOrderConfig struct
  """
  takeOrderConfigBytes: Bytes!
  """
  The orderbook this trade event is for
  """
  orderbook: Orderbook!
  """
  The trades that occured in this event
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]!
  transaction: Transaction!
  """
  The msg.sender of this trade
  """
  sender: Bytes!
}

input TakeOrder_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  inputAmount: BigInt
  inputAmount_not: BigInt
  inputAmount_gt: BigInt
  inputAmount_lt: BigInt
  inputAmount_gte: BigInt
  inputAmount_lte: BigInt
  inputAmount_in: [BigInt!]
  inputAmount_not_in: [BigInt!]
  outputAmount: BigInt
  outputAmount_not: BigInt
  outputAmount_gt: BigInt
  outputAmount_lt: BigInt
  outputAmount_gte: BigInt
  outputAmount_lte: BigInt
  outputAmount_in: [BigInt!]
  outputAmount_not_in: [BigInt!]
  takeOrderConfigBytes: Bytes
  takeOrderConfigBytes_not: Bytes
  takeOrderConfigBytes_gt: Bytes
  takeOrderConfigBytes_lt: Bytes
  takeOrderConfigBytes_gte: Bytes
  takeOrderConfigBytes_lte: Bytes
  takeOrderConfigBytes_in: [Bytes!]
  takeOrderConfigBytes_not_in: [Bytes!]
  takeOrderConfigBytes_contains: Bytes
  takeOrderConfigBytes_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  trades_: Trade_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TakeOrder_filter]
  or: [TakeOrder_filter]
}

enum TakeOrder_orderBy {
  id
  inputAmount
  outputAmount
  takeOrderConfigBytes
  orderbook
  orderbook__id
  trades
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type Trade {
  id: Bytes!
  """
  The orderbook this trade is for
  """
  orderbook: Orderbook!
  """
  The order that was traded
  """
  order: Order!
  """
  Input vault balance change
  """
  inputVaultBalanceChange: TradeVaultBalanceChange!
  """
  Output vault balance change
  """
  outputVaultBalanceChange: TradeVaultBalanceChange!
  """
  The event in which this trade occured
  """
  tradeEvent: TradeEvent!
  """
  The timestamp this trade was executed
  """
  timestamp: BigInt!
}

interface TradeEvent {
  id: Bytes!
  """
  The orderbook this trade event is for
  """
  orderbook: Orderbook!
  """
  The trades that occured in this event
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]!
  transaction: Transaction!
  """
  The msg.sender of this trade
  """
  sender: Bytes!
}

input TradeEvent_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  trades_: Trade_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TradeEvent_filter]
  or: [TradeEvent_filter]
}

enum TradeEvent_orderBy {
  id
  orderbook
  orderbook__id
  trades
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

type TradeVaultBalanceChange implements VaultBalanceChange {
  id: Bytes!
  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!
  """
  The trade that this balance change is for
  """
  trade: Trade!
  """
  The vault that was affected
  """
  vault: Vault!
  """
  The amount that was changed - this is signed
  """
  amount: BigInt!
  """
  The balance of the vault before the change
  """
  oldVaultBalance: BigInt!
  """
  The balance of the vault after the change
  """
  newVaultBalance: BigInt!
  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!
  """
  The transaction in which this balance change was executed
  """
  transaction: Transaction!
}

input TradeVaultBalanceChange_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  trade: String
  trade_not: String
  trade_gt: String
  trade_lt: String
  trade_gte: String
  trade_lte: String
  trade_in: [String!]
  trade_not_in: [String!]
  trade_contains: String
  trade_contains_nocase: String
  trade_not_contains: String
  trade_not_contains_nocase: String
  trade_starts_with: String
  trade_starts_with_nocase: String
  trade_not_starts_with: String
  trade_not_starts_with_nocase: String
  trade_ends_with: String
  trade_ends_with_nocase: String
  trade_not_ends_with: String
  trade_not_ends_with_nocase: String
  trade_: Trade_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  oldVaultBalance: BigInt
  oldVaultBalance_not: BigInt
  oldVaultBalance_gt: BigInt
  oldVaultBalance_lt: BigInt
  oldVaultBalance_gte: BigInt
  oldVaultBalance_lte: BigInt
  oldVaultBalance_in: [BigInt!]
  oldVaultBalance_not_in: [BigInt!]
  newVaultBalance: BigInt
  newVaultBalance_not: BigInt
  newVaultBalance_gt: BigInt
  newVaultBalance_lt: BigInt
  newVaultBalance_gte: BigInt
  newVaultBalance_lte: BigInt
  newVaultBalance_in: [BigInt!]
  newVaultBalance_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TradeVaultBalanceChange_filter]
  or: [TradeVaultBalanceChange_filter]
}

enum TradeVaultBalanceChange_orderBy {
  id
  orderbook
  orderbook__id
  trade
  trade__id
  trade__timestamp
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
}

input Trade_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  order: String
  order_not: String
  order_gt: String
  order_lt: String
  order_gte: String
  order_lte: String
  order_in: [String!]
  order_not_in: [String!]
  order_contains: String
  order_contains_nocase: String
  order_not_contains: String
  order_not_contains_nocase: String
  order_starts_with: String
  order_starts_with_nocase: String
  order_not_starts_with: String
  order_not_starts_with_nocase: String
  order_ends_with: String
  order_ends_with_nocase: String
  order_not_ends_with: String
  order_not_ends_with_nocase: String
  order_: Order_filter
  inputVaultBalanceChange: String
  inputVaultBalanceChange_not: String
  inputVaultBalanceChange_gt: String
  inputVaultBalanceChange_lt: String
  inputVaultBalanceChange_gte: String
  inputVaultBalanceChange_lte: String
  inputVaultBalanceChange_in: [String!]
  inputVaultBalanceChange_not_in: [String!]
  inputVaultBalanceChange_contains: String
  inputVaultBalanceChange_contains_nocase: String
  inputVaultBalanceChange_not_contains: String
  inputVaultBalanceChange_not_contains_nocase: String
  inputVaultBalanceChange_starts_with: String
  inputVaultBalanceChange_starts_with_nocase: String
  inputVaultBalanceChange_not_starts_with: String
  inputVaultBalanceChange_not_starts_with_nocase: String
  inputVaultBalanceChange_ends_with: String
  inputVaultBalanceChange_ends_with_nocase: String
  inputVaultBalanceChange_not_ends_with: String
  inputVaultBalanceChange_not_ends_with_nocase: String
  inputVaultBalanceChange_: TradeVaultBalanceChange_filter
  outputVaultBalanceChange: String
  outputVaultBalanceChange_not: String
  outputVaultBalanceChange_gt: String
  outputVaultBalanceChange_lt: String
  outputVaultBalanceChange_gte: String
  outputVaultBalanceChange_lte: String
  outputVaultBalanceChange_in: [String!]
  outputVaultBalanceChange_not_in: [String!]
  outputVaultBalanceChange_contains: String
  outputVaultBalanceChange_contains_nocase: String
  outputVaultBalanceChange_not_contains: String
  outputVaultBalanceChange_not_contains_nocase: String
  outputVaultBalanceChange_starts_with: String
  outputVaultBalanceChange_starts_with_nocase: String
  outputVaultBalanceChange_not_starts_with: String
  outputVaultBalanceChange_not_starts_with_nocase: String
  outputVaultBalanceChange_ends_with: String
  outputVaultBalanceChange_ends_with_nocase: String
  outputVaultBalanceChange_not_ends_with: String
  outputVaultBalanceChange_not_ends_with_nocase: String
  outputVaultBalanceChange_: TradeVaultBalanceChange_filter
  tradeEvent: String
  tradeEvent_not: String
  tradeEvent_gt: String
  tradeEvent_lt: String
  tradeEvent_gte: String
  tradeEvent_lte: String
  tradeEvent_in: [String!]
  tradeEvent_not_in: [String!]
  tradeEvent_contains: String
  tradeEvent_contains_nocase: String
  tradeEvent_not_contains: String
  tradeEvent_not_contains_nocase: String
  tradeEvent_starts_with: String
  tradeEvent_starts_with_nocase: String
  tradeEvent_not_starts_with: String
  tradeEvent_not_starts_with_nocase: String
  tradeEvent_ends_with: String
  tradeEvent_ends_with_nocase: String
  tradeEvent_not_ends_with: String
  tradeEvent_not_ends_with_nocase: String
  tradeEvent_: TradeEvent_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Trade_filter]
  or: [Trade_filter]
}

enum Trade_orderBy {
  id
  orderbook
  orderbook__id
  order
  order__id
  order__active
  order__orderHash
  order__owner
  order__nonce
  order__orderBytes
  order__meta
  order__timestampAdded
  inputVaultBalanceChange
  inputVaultBalanceChange__id
  inputVaultBalanceChange__amount
  inputVaultBalanceChange__oldVaultBalance
  inputVaultBalanceChange__newVaultBalance
  inputVaultBalanceChange__timestamp
  outputVaultBalanceChange
  outputVaultBalanceChange__id
  outputVaultBalanceChange__amount
  outputVaultBalanceChange__oldVaultBalance
  outputVaultBalanceChange__newVaultBalance
  outputVaultBalanceChange__timestamp
  tradeEvent
  tradeEvent__id
  tradeEvent__sender
  timestamp
}

type Transaction {
  id: Bytes!
  timestamp: BigInt!
  blockNumber: BigInt!
  from: Bytes!
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter
  ): [Event!]
}

input Transaction_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  events_: Event_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Transaction_filter]
  or: [Transaction_filter]
}

enum Transaction_orderBy {
  id
  timestamp
  blockNumber
  from
  events
}

type Vault {
  id: Bytes!
  """
  The orderbook this vault is in
  """
  orderbook: Orderbook!
  """
  The token that this vault is for
  """
  token: ERC20!
  """
  The owner of this vault
  """
  owner: Bytes!
  """
  The vaultId of this vault
  """
  vaultId: BigInt!
  """
  Orders this vault is an input for
  """
  ordersAsInput(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
  ): [Order!]!
  """
  Orders this vault is an output for
  """
  ordersAsOutput(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
  ): [Order!]!
  """
  The amount of the token that is in this vault
  """
  balance: BigInt!
  """
  All balance changes for this vault
  """
  balanceChanges(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultBalanceChange_orderBy
    orderDirection: OrderDirection
    where: VaultBalanceChange_filter
  ): [VaultBalanceChange!]!
}

interface VaultBalanceChange {
  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!
  """
  The vault that was affected
  """
  vault: Vault!
  """
  The amount changed - this is signed
  """
  amount: BigInt!
  """
  The balance of the vault before the change
  """
  oldVaultBalance: BigInt!
  """
  The balance of the vault after the change
  """
  newVaultBalance: BigInt!
  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!
  """
  The transaction in which this balance change was executed
  """
  transaction: Transaction!
}

input VaultBalanceChange_filter {
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  oldVaultBalance: BigInt
  oldVaultBalance_not: BigInt
  oldVaultBalance_gt: BigInt
  oldVaultBalance_lt: BigInt
  oldVaultBalance_gte: BigInt
  oldVaultBalance_lte: BigInt
  oldVaultBalance_in: [BigInt!]
  oldVaultBalance_not_in: [BigInt!]
  newVaultBalance: BigInt
  newVaultBalance_not: BigInt
  newVaultBalance_gt: BigInt
  newVaultBalance_lt: BigInt
  newVaultBalance_gte: BigInt
  newVaultBalance_lte: BigInt
  newVaultBalance_in: [BigInt!]
  newVaultBalance_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [VaultBalanceChange_filter]
  or: [VaultBalanceChange_filter]
}

enum VaultBalanceChange_orderBy {
  orderbook
  orderbook__id
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
}

input Vault_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: ERC20_filter
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  vaultId: BigInt
  vaultId_not: BigInt
  vaultId_gt: BigInt
  vaultId_lt: BigInt
  vaultId_gte: BigInt
  vaultId_lte: BigInt
  vaultId_in: [BigInt!]
  vaultId_not_in: [BigInt!]
  ordersAsInput_: Order_filter
  ordersAsOutput_: Order_filter
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  balanceChanges_: VaultBalanceChange_filter
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Vault_filter]
  or: [Vault_filter]
}

enum Vault_orderBy {
  id
  orderbook
  orderbook__id
  token
  token__id
  token__address
  token__name
  token__symbol
  token__decimals
  owner
  vaultId
  ordersAsInput
  ordersAsOutput
  balance
  balanceChanges
}

type Withdrawal implements Event & VaultBalanceChange {
  id: Bytes!
  """
  The amount that was being targeted to be withdrawn
  """
  targetAmount: BigInt!
  """
  The orderbook this balance change is for
  """
  orderbook: Orderbook!
  """
  The vault that was withdrawn from
  """
  vault: Vault!
  """
  The amount that was actually withdrawn - this will be negative
  """
  amount: BigInt!
  oldVaultBalance: BigInt!
  newVaultBalance: BigInt!
  """
  The timestamp this balance change was executed
  """
  timestamp: BigInt!
  transaction: Transaction!
  """
  The msg.sender of this withdrawal
  """
  sender: Bytes!
}

input Withdrawal_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  targetAmount: BigInt
  targetAmount_not: BigInt
  targetAmount_gt: BigInt
  targetAmount_lt: BigInt
  targetAmount_gte: BigInt
  targetAmount_lte: BigInt
  targetAmount_in: [BigInt!]
  targetAmount_not_in: [BigInt!]
  orderbook: String
  orderbook_not: String
  orderbook_gt: String
  orderbook_lt: String
  orderbook_gte: String
  orderbook_lte: String
  orderbook_in: [String!]
  orderbook_not_in: [String!]
  orderbook_contains: String
  orderbook_contains_nocase: String
  orderbook_not_contains: String
  orderbook_not_contains_nocase: String
  orderbook_starts_with: String
  orderbook_starts_with_nocase: String
  orderbook_not_starts_with: String
  orderbook_not_starts_with_nocase: String
  orderbook_ends_with: String
  orderbook_ends_with_nocase: String
  orderbook_not_ends_with: String
  orderbook_not_ends_with_nocase: String
  orderbook_: Orderbook_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  oldVaultBalance: BigInt
  oldVaultBalance_not: BigInt
  oldVaultBalance_gt: BigInt
  oldVaultBalance_lt: BigInt
  oldVaultBalance_gte: BigInt
  oldVaultBalance_lte: BigInt
  oldVaultBalance_in: [BigInt!]
  oldVaultBalance_not_in: [BigInt!]
  newVaultBalance: BigInt
  newVaultBalance_not: BigInt
  newVaultBalance_gt: BigInt
  newVaultBalance_lt: BigInt
  newVaultBalance_gte: BigInt
  newVaultBalance_lte: BigInt
  newVaultBalance_in: [BigInt!]
  newVaultBalance_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Withdrawal_filter]
  or: [Withdrawal_filter]
}

enum Withdrawal_orderBy {
  id
  targetAmount
  orderbook
  orderbook__id
  vault
  vault__id
  vault__owner
  vault__vaultId
  vault__balance
  amount
  oldVaultBalance
  newVaultBalance
  timestamp
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  transaction__from
  sender
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes
  """
  The block number
  """
  number: Int!
  """
  Integer representation of the timestamp stored in blocks for the chain
  """
  timestamp: Int
  """
  The hash of the parent block
  """
  parentHash: Bytes
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block

  """
  block: _Block_!
  """
  The deployment ID
  """
  deployment: String!
  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

